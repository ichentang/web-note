# 一、React

## 1. react简介

### **介绍**		

​	React，用于构建用户界面的框架，只提供了 UI 层面的解决方案。



### **特性**

1. 声明式设计：

​		React采用声明式编程，声明式编程是一种编程范式，它关注的是你要做什么，而不是怎么做，它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件，可以轻松描述应用。

​		声明式编程方式使得 React 组件很容易使用，最终的代码简单易于维护。

2. 组件化：

​		 在 React 中，一切皆为组件。

​		 可组合：每个组件易于和其它组件一起使用，或者嵌套在另一个组件。

​		 可重用：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景。

​		 可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护。

3. JSX 语法。

4. 单向数据绑定。

​		 为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变（使用this.setState()更改数据）。所以应该说没有好坏之分，Vue更加简单，而React便于构建大型应用。

​		 不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。

 

### 优点

高效：React通过对DOM的模拟，最大限度地减少与DOM的交互。

灵活：React可以与已知的库或框架很好地配合。

声明式的设计，简单使用。

组件式开发，提高代码复用率。

单向响应的数据流会比双向绑定的更安全，速度更快。



## 2. jsx编译为真实dom步骤

1、会基于babel-preset-react-app语法包，把 jsx变为React.createElement这种模式。

2、通过React.createElement这个方法的执行生成一个对象（虚拟DOM对象）。

3、基于react-dom中render方法，把创建的虚拟DOM对象（JSX对象）变成真实的dom，放到页面指定的容器中。



## 3. react和vue区别

### 相同点

1. 组件化

   ​	**组件是独立和可复用的代码组织单元**，它使开发者使用小型、独立和通常可复用的组件构建大型应用。

   ​	组件化开发能大幅提高应用开发效率、测试性、复用性等。

   ​	降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求。

   ​	调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单。

   ​	提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级。

   

2. 虚拟DOM

   ​	**相同**： Vue与React都使用了 Virtual DOM + Diff算法， 不管是Vue的Template模板+options api 写法， 还是React的Class或者Function写法,最后都是生成render函数，而render函数执行返回VNode(虚拟DOM的数据结构，本质上是棵树)。

   ​	当每一次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM（虚拟DOM是JS对象结构，同样在JS引擎中，而真实DOM在浏览器渲染引擎中，所以操作虚拟DOM比操作真实DOM开销要小的多）。

   

   ​	**不同**：react 会自顶向下全diff。vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树。

   ​	在react中，当状态发生改变时，组件树就会自顶向下的全diff, 重新render页面， 重新生成新的虚拟dom tree, 新旧dom tree进行比较， 进行patch打补丁方式，局部更新dom。所以react为了避免父组件更新而引起不必要的子组件更新， 可以在shouldComponentUpdate做逻辑判断，减少没必要的render， 以及重新生成虚拟dom，做差量对比过程。

   ​	在vue中， 通过Object.defineProperty 把 data 属性全部转为 getter/setter。同时watcher实例对象会在组件渲染时，将属性记录为dep, 当dep 项中的 setter被调用时，通知watch重新计算，使得关联组件更新。

​			![image-20221217110017451](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221217110017451.png)



3. 数据驱动视图

   就是数据变化的时候，相应的视图会得到更新。开发者只需要关注数据的变化而不用再去手动的操作DOM。

   

   react的数据驱动视图：

   首先了解一些内容：

   ​	pending：当前所有等待更新的state队列。

   ​	isBatchingUpdates：React中用于标识当前是否处理批量更新状态，默认false。

   ​	dirtyComponent：当前所有待更新state的组件队列。

   ​	React通过setState实现数据驱动视图，通过setState来引发一次组件的更新过程从而实现页面的重新渲染(除非shouldComponentUpdate返回false)。

    

   工作步骤：

   1. setState()首先将接收的第一个参数state存储在pending队列中；（state）。

   2. 判断当前React是否处于批量更新状态，是的话就将需要更新state的组件添加到dirtyComponents中；（组件）。

   3. 不是的话，它会遍历dirtyComponents的所有组件，调用updateComponent方法更新每个dirty组件（开启批量更新事务）。



### 不同点

​	1. 监听数据变化的实现原理不同

​	Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能。

​	React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染。

​	为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变。所以应该说没有好坏之分，Vue更加简单，而React便于构建大型应用。



2. 数据流不同：

​	 Vue中默认是支持双向绑定的。在Vue1.0中我们可以实现两种双向绑定：

​		父子组件之间，props 可以双向绑定。

​		组件与DOM之间可以通过 v-model 双向绑定。

​		在 Vue2.x 中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且 Vue2.x 已经不鼓励组件对自己的 props 进行任何修改了。

​		所以现在我们只有 组件 <--> DOM 之间的双向绑定这一种。

 

​	React 从诞生之初就不支持双向绑定，React一直提倡的是单向数据流，他称之为 onChange/setState()模式。

​	不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。

 

3. 模板渲染方式的不同

​	在表层上， 模板的语法不同：

​		React 是通过JSX渲染模板。

​		而Vue是通过一种拓展的HTML语法进行渲染。

​	但其实这只是表面现象，毕竟React并不必须依赖JSX。

​	模板的原理不同，这才是他们的本质区别：

​		React是在组件JS代码中，通过原生JS实现模板中的常见语法，条件，循环等，都是通过JS语法实现的。

​		Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，条件语句就需要 v-if 实现。

 

​	对这一点，React的做法更加纯粹更加原生，而Vue的做法显得有些独特。举个例子，说明React的好处：

​	react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下。

![image-20221217110858315](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221217110858315.png)





## 4. react、vue中key的作用

​	key是虚拟DOM的标识，它会帮助react识别哪些元素被修改、添加或移除，避免频繁更新不同元素，从而高效的更新DOM，减少DOM操作，提高性能。

**1. 虚拟DOM中key的作用：**

​    key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，

​    随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

**2.对比规则**

​		(1).旧虚拟D0M中找到了与新虚拟D0M相同的key:

​				若虚拟D0M中内容没变，直接使用之前的真实DOM！

​				若虚拟D0M中内容变了，则生成新的真实D0M，随后替换掉页面中之前的真实D0M。

​		(2).旧虚拟D0M中未找到与新虚拟D0M相同的key：

​				创建新的真实D0M，随后渲染到页面。	

**3.用index作为key可能会引发的问题：**

​		(1).若对数据进行：逆序添加、逆序删除等破坏顺序操作：

​				会产生没有必要的真实D0M更新 ==> 界面效果没问题，但效率低。

​		(2).如果结构中还包含输入类的D0M：

​				会产生错误的D0M更新 ==> 界面有问题。

**4.开发中如何选择key?**

​		(1).最好使用每条故据的唯一标识作为key,比如id、手机号、身份证号、学号等唯一值.

​		(2).如果不存在对数据的逆序添加、逆序别除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。







## 5. 当执行setState时发生了什么

​	将传递给setState的参数合并到当前组件的状态，构建一个新的react元素树，与上一个元素树进行对比找出不同，根据不同对界面进行按需更新，而不是全部渲染。



## 6. setState

(1) setState的参数为什么是callback？

   因为this.props、this.state的更新可能是异步的，不能依赖它们去计算下一个state。

(2) 第二个参数作用？

   在状态更新页面完成渲染后立刻拿到数据，此时通过callback拿到最新设置的值。

(3) 异步同步？

​	在合成事件和生命周期中是异步的（目的是优化性能，减少不必要的渲染，在同一个事件中多次执行setState，多个setState会存放到一个异步队列中，只执行最后一次）。

​	 在原生事件和异步中是同步的。



## 7. 状态(state)和属性(props)有何区别

​	它们都是用来保存信息的，这些信息用来控制组件的渲染。

​	props是传递给子组件的（类似函数的形参）。

​    state是组件挂载时所需数据的默认值（类似于函数中声明的变量）。

​    props针对子组件而言是不可修改的（类似于纯函数）。

​    state是可以修改的。



## 8. 应该在react何处发送Ajax请求

​	应该在componentDidMount中发送网络请求，这个方法会在组件首次挂载到DOM后执行。因为不能在一个未挂载的组件中调用setState，没任何作用。在componentDidMount中发送网络请求会确保组件已经挂载完可以更新了。



## 9. react中构建组件的三种方式

 使用react.component（Es6的class类）

 使用react.createClass

 无状态函数



## 10. React中refs作用

 获取组件实例或DOM元素。

 创建refs三种方式：字符串、回调函数、react.createref()。

 应用场景：

​	对Dom元素的焦点控制、内容选择、控制。

​	对Dom元素的内容设置及媒体播放。

​	对Dom元素的操作和对组件实例的操作。



## 11. React diff 算法

 概念：diff算法是react中提升渲染性能的优化算法。

 作用：计算出虚拟DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非渲染整个页面。 

​		react需要同时维护两棵虚拟DOM树，一棵是当前的DOM结构，另一棵是react中状态变化后新生成的虚拟DOM树。React通过对比两个树的区别，决定是否或怎么去修改DOM结构。这种算法被称为diff算法。

​		这个算法问题有一些通用的解决方案，但复杂度为O(n3)，在react中使用该算法，那么1000个元素所需的计算量在10亿次左右，所以react在以下两个假设的基础上提出了一套复杂度为O(n)的启发式算法：

1. 两个相同类型的元素会产生相似的树，两个不同类型的元素会产生不同的树。

2. 使用key属性标识哪些子元素在不同渲染中可能是不变的。

 

​	React diff 算法的实现基本都是基于以上两个假设实现的，因此可以分为三种情况，对比相同类型的元素、对比不同类型的元素、对比列表节点：

​	对比相同类型的元素：react会保留原有的DOM，仅更改变化的属性。

​	对比不同类型的元素：当根节点为不同类型的元素时，react会拆掉原有的树重新建立新的树。

​	对比列表节点：主要有三种情况，添加节点、删除节点、排序节点。通过添加唯一key值简化diff算法，减少DOM操作。



## 12. React优势

1. 虚拟DOM：react使用了虚拟DOM，实现了对实际DOM的局部更新，速度快，减少并优化了对DOM的操作，性能高。并提供了标准化的API，解决了跨浏览器问题。

2. 组件化：使代码变得清晰隔离，提高复用性可维护性。

3. 单向数据流 ： React提出的flux模式来进行组件数据传输，好处是所有变化是可预计的可控制的。

4. 同构、纯粹的JavaScript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。

5. 兼容性好：使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。

  缺点：react只是视图层的一个框架，并不是一个完整的框架，需要构建大型项目时，需依赖它的生态系统（处理路由使用react-router-dom，处理数据使用redux）。



## 13. React生命周期函数

![image-20221217115105524](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221217115105524.png)



 挂载时

​	**constructor：**

​		实例过程中自动调用的方法，在方法内部通过super关键字获取来自父组件的props，在该方法中，通常的操作为初始化state状态或者在this上挂载方法。

​	**getDerivedStateFromProps：**

​		参数（props为传递的参数，state为当前组件现在（还未更新）的参数）。

​		静态方法，因此不能访问组件实例。替换了componentWillMount 、	componentWillReceiveProps，给两者的功能合并。

​		执行时机：组件创建和更新阶段，不论是props变化还是state变化，也会调用。

​		在每次render方法前调用，第一个参数为即将更新的props，第二个参数为上一个状态的state，可以比较props 和 state来加一些限制条件，防止无用的state更新。

​		该方法需要返回一个新的对象作为新的state或者返回null表示state状态不需要更新。

​	**render：**

​		类组件必须实现的方法，用于渲染DOM结构，可以访问组件state与prop属性。

​	**componentDidMount：**

​		组件挂载到真实DOM节点后执行，其在render方法之后执行。

​		此方法多用于执行一些数据获取，事件监听等操作。



 更新时

​	**getDerivedStateFromProps**

​	**shouldComponentUpdate：**

​		参数（nextProps是下一次的props，nextState是下一次的状态）。

​		 当组件嵌套时候，父组件的props或者state任意一个被修改，都会触发该组件和所有的后代组件的更新。

​		 should生命周期钩子是用来做性能优化的，避免没必要的更新。但是需要手动判断是否更新。

​		 PureComponent 和 Component 几乎一样。

​		区别：PureComponent会对props和state进行浅层比较，PureComponent是高性能组件(类组件中的高性能组件)。

​	 **render：**

​	 **getSnapshotBeforeUpdate：**

​		 执行之时DOM元素还没有被更新。快照，prevProps：传递过来的参数，prevState：本组件的状态

​	 	需要有返回值，返回值是一个对象，此生命周期的任何返回值将作为参数传递给componentDidUpdate()。

​		 此方法的目的在于获取组件更新前的一些信息，比如组件的滚动位置之类的，在组件更新后可以根据这些信息恢复一些UI视觉上的状态。

​	 **componentDidUpdate：**

​		执行时机：组件更新结束后触发。

​		在该方法中，可以根据前后的props和state的变化做相应的操作，如获取数据，修改DOM样式等。



卸载时

 **componentDidUnmount：**

​		此方法用于组件卸载前，清理一些注册时监听事件，或者取消订阅的网络请求等。

​		一旦一个组件实例被卸载，其不会被再次挂载，而只可能是被重新创建。



## 14. React 中的事件代理

1. 我们写的事件是绑定在哪里？

	​	React16版本中，在jsx中绑定的事件，根本没注册到真实DOM上。是绑定到document上统一管理的。
	​	React17版本中，是绑定到container上统一管理的。这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取全部绑定在document上，那么可能多应用下会出现问题。
	
	

2. 什么是react事件合成？

​		React中绑定的onClick并不是原生事件，而是由原生的事件合成的react事件。（click事件合成为onClick，input、change、keyup合成为onchange）。



3. 为什么采用事件合成?

​		一方面是将事件都代理到根节点上管理，减少了事件监听器的创建，节省了内存，另一方面是react要实现全浏览器框架，为了抹平不同浏览器的差异。

 

​	在react16中，对document的事件委托都委托在冒泡阶段，当事件冒泡到document后触发绑定的回调函数，在回调函数中重新模拟一次捕获-冒泡的行为，所以react事件中的e.stopPropagation()无法阻止原生事件的捕获和冒泡，因为原生事件的捕获和冒泡已经执行完了。

​	在react17中，对React应用根DOM容器的事件委托分别在捕获阶段和冒泡阶段。即：

当根容器接收到捕获事件时，先触发一次React事件的捕获阶段，然后再执行原生事件的捕获传播。所以React事件的捕获阶段调用e.stopPropagation()能阻止原生事件的传播。

​	当根容器接收到冒泡事件时，会触发一次React事件的冒泡阶段，此时原生事件的冒泡传播已经传播到根了，所以React事件的冒泡阶段调用e.stopPropagation()不能阻止原生事件向根容器的传播，但是能阻止根容器到页面顶层的传播。





## 15. this的各种情况

1. 以函数形式调用，this是window。

2. 以方法形式调用，this是调用方法的实例。

3. 以构造函数形式调用时，this是新创建的实例。

4. 使用call、apply调用，this是所指定的实例。

5. 箭头函数：箭头函数外层是否有函数，有函数则外层函数this就是箭头函数this，无函数是window。





## 16. Promise怎么异常处理

定义：是一门新的技术（es6规范），为了解决异步存在的方案。

语法：是一个构造函数。

功能：用来封装一个异步操作并获取其成功/失败的结果。

异常处理：reject或catch处理异常。



## 17. react怎么做数据检查和变化

​	 props、state。





## 18. 大文件上传以及断点续传

具备的功能：

1. 需要校验文件格式。

2. 可以上传任何文件，包括超大的视频文件（切片）。

3. 上传期间断网后，再次联网可以继续上传（断点续传）。

4. 要有进度条提示。

5. 已经上传过同一个文件后，直接上传完成（秒传）。

 

实现 前端步骤：

1. 文件格式校验，上传前先校验视频格式，用的自己封装的uploadVideo上传组件。 

2. 文件切片（使用Blob.prototype.slice进行切片处理）、使用spark-md5计算出文件的hash值，在拿到切片和md5后，我们首先去服务器查询一下，是否已经存在当前文件。

​		(1) 已存在，并且已经上传成功，则直接返回成功，实现秒传。

​		(2) 已存在，并且有一部分切片上传失败，则返回给前端已经上传成功的切片序号，前端拿到后，根据返回的切片，计算出未上传成功的剩余切片，然后把剩余的切片继续上传，即可实现"断点续传"。

​		(3) 不存在，则开始上传，这里需要注意的是，在并发上传切片时，需要控制并发量，避免一次性上传过多切片，导致崩溃。

3. 上传进度计算。

4. 上传完成后通知后端合并切片。

 

实现 后端步骤：

1. 检查接收到的hash是否有相同的文件，并通知前端当前hash是否有未完成的上传。

2. 接收切片。

3. 合并所有切片。

 

遇到的问题：分块的上传请求失败了，怎么办？

​	一旦服务端某个上传请求失败，会返回406（切片上传失败，在后台会有记录)，和当前分块失败的信息，其中会包含文件名称、文件 hash、分块大小以及分块序号等，前端拿到这些信息后可以进行重传。



## 19. 通过什么做到并发请求

 Promise.all或者web worker。



## 20. redux

作用：是可预测化的公共状态管理工具，对数据进行管理，派发更新，更新视图渲染的作用。



**工作原理/步骤：**

1. 首先通过createStore创建一个 store（公共存储空间），state数据都放在 store公共存储空间。

2. 用户通过view视图层触发事件，这时需发出一个指令，action就是改变state的指令，通过store.dispatch 派发到store。

3. store通知reducer,由reducer(加工的机器)计算出state，返回新的state，更新视图。



遵循三大基本原则：

​		单一数据源。

​		state 是只读的。

​		使用纯函数来执行修改。



action作用：一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性：

​		type：action 类型；

​		payload：负载数据；

 

reducer作用：

​	reducer是纯函数，它规定应用程序的状态怎样因响应action而改变。reducer通过接收先前的状态和action来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。当不需要完成任务，它会返回原来的状态。



Store 作用：

就是把它们联系到一起。Store 有以下职责：

​	维护应用状态并支持访问状态（getState()）；

​	提供 dispatch(action) 方法更新 state；

​	支持订阅store的变更：subscribe(listener)：设置 state 变化的监听函数（若把视图更新函数作为 listener 传入，则可触发视图自动渲染）。



**redux中怎么处理异步？**

​	使用redux-thunk中间件。

​	redux中，中间件就是放在就是在dispatch过程，在分发action进行拦截处理。

​	其本质上是一个函数，对store.dispatch方法进行了改造，在发出 Action和执行 Reducer这两步之间，添加了其他功能。

​	中间件都需要通过applyMiddlewares进行注册，作用是将所有的中间件组成一个数组，依次执行。

​	 redux-thunk中间件会判断你当前传进来的数据类型，是一个函数，将会给函数传参数值	（dispatch，getState）。

​    dispatch函数用于我们之后再次派发action。

​	getState函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态。

 

​	thunk实现，10多行代码：

```js
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => next => action => {
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }

    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
export default thunk;
```

​	这几行代码做的事情也很简单，判别action的类型，如果action是函数，就调用这个函数，调用的步骤为：

​	action(dispatch, getState, extraArgument);

​	发现实参为dispatch和getState，因此我们在定义action为thunk函数是，一般形参为dispatch和getState。



Provider 和 connect：

前者使 React 组件可被连接（connectable），后者把 React 组件和 Redux 的 store 真正连接起来。

```
原理解析
	首先connect之所以会成功，是因为Provider组件：
		在原应用组件上包裹一层，使原来整个应用成为Provider的子组件
		接收Redux的store作为props，通过context传递给子孙组件上的connect

那connect做了些什么呢？
	它真正连接 Redux 和 React，它包在我们的容器组件的外一层，它接收上面 Provider 提供的 store 里面的 state 和 dispatch，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。

关于它的源码：
	connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产Component的函数，然后再将真正的Component作为参数传入wrapWithConnect，这样就生产出一个经过包裹的Connect组件，该组件特点:
	通过props.store获取祖先Component的store。
	props包括stateProps、dispatchProps、parentProps,合并在一起得到nextState，作为props传给真正的Component。
	componentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互。
	shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState。
	componentWillUnmount时移除注册的事件this.handleChange。
```



 优点：

​	 结果的可预测性：单向数据流、单一数据源，只存在一个数据源store。

​	可维护性：具有可预测的结果和严格的结构。

​	社区和生态系统。

​	便于测试。

 缺点：

​	一个组件所需要的数据必须由父组件传过来而不能像flux中直接从store获取。

​	当一个组件相关数据更新时即使父组件不需要用到这个组件父组件还是会重新render可能会有效率影响或者需要写复杂的shouldComponentUpdate进行判断。

![image-20221220145032105](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220145032105.png)





## 21. react组件通讯方式

父组件向子组件传递：

​	只需要在子组件标签内传递参数，子组件通过props属性就能接收父组件传递过来的参数。

子组件向父组件传递：

 	父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值。

兄弟组件之间的通信：

 	父组件作为中间层来实现数据的互通，通过使用父组件传递。

父组件向后代组件传递：

 	使用context提供了组件之间通讯的一种方式，可以共享数据，其他数据都能读取对应的数据。

1. 通过使用React.createContext创建一个context。

2. context创建成功后，其下存在Provider组件用于创建数据源（组件通过value属性用于给后代组件传递数据），Consumer组件用于接收数据（通过Consumer组件或者或者使用contextType属性接收）。

非关系组件传递：

​	建议将数据进行一个全局资源管理，redux。



## 22. react怎么进行组件/逻辑复用

1. 高阶组件（HOC）：

   是一个高阶函数，接受一个或多个组件作为参数，返回加工过的新组件，本质也就是一个函数，并不是一个组件。

   高阶组件的这种实现方式，本质上是一个装饰者设计模式。

![image-20221220153412066](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220153412066.png)

需注意：

​	props 保持一致。

​	你不能在函数式（无状态）组件上使用 ref 属性，因为它没有实例。

​	不要以任何方式改变原始组件。

​	不要再 render() 方法中使用高阶组件。

​	使用 compose 组合高阶组件。

​	包装显示名字以便于调试。

 	

​	高阶组件可以传递所有的props，但是不能传递ref，添加refs引用，那么ref 指向的是最外层容器组件实例的，而不是被包裹的组件,传递refs的话，则使用React.forwardRef。

​	高阶组件能够提高代码的复用性和灵活性，在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，权限控制、日志记录、数据校验、异常处理、统计上报。

 	举个例子，存在一个组件，需要从缓存中获取数据，然后渲染。

![image-20221220154127247](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220154127247.png)

缺点：

 难以溯源。组件使用多个HOC加工，不清楚属性来自哪个HOC。

 props属性名冲突。



2. Hooks：

   概念：React hooks是react16.8 以后，react新增的钩子API，目的是增加代码的可复用性，逻辑性，弥补无状态组件没有生命周期，没有数据管理状态state的缺陷。

    

   解决什么？

   ​	没有 Hooks，函数组件能够做的只是接受 Props、渲染 UI ，以及触发父组件传过来的事件。所有的处理逻辑都要在类组件中写，这样会使 class 类组件内部错综复杂，每一个类组件都有一套独特的状态，相互之间不能复用。

   ​	类组件之间的状态会随着功能增强而变得越来越臃肿，代码维护成本也比较高，而且不利于后期 tree shaking。所以有必要做出一套函数组件代替类组件的方案，于是 Hooks 也就理所当然的诞生了。

    

   所以 Hooks 出现本质上原因是：

   1. 让函数组件也能做类组件的事，有自己的状态，可以处理一些副作用，能获取 ref ，也能做数据缓存。

   2. 解决逻辑复用难的问题。

   3. 通过自定义hook能够更好的封装我们的功能。
   4. 编写hooks为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅。





## 23. 类组件和函数组件区别

类组件：

 定义：顾名思义，通过ES6类的编写形式去编写组件，该类必须继承React.Component,通过构造函数接收props来访问父组件传递的参数。

函数组件：

 定义：顾名思义，通过函数编写形式去实现React组件，函数的第一个参数props，用于接受父组件传递的参数。

 

区别：

 编写形式：两者最明显的区别在于编写形式的不同，同一个功能的实现可以通过类组件和函数组件的编写形式。

 状态管理：在hook出来之前，函数组件就是无状态组件，不能存储组件的状态，不能像类组件中调用setState存储和更改状态。函数组件状态管理需要用useState。

 调用方式：函数组件执行该函数即可，类组件需要进行实例化。

 生命周期：函数组件没有生命周期,没有this指向，因为这些生命周期钩子都来自于继承的React.Component。

 函数组件优势：底层api比较轻量，改造成本小（不会影响原来的组件层次结构），组件中的状态和UI变得清晰和隔离。



## 24. MVC框架主要问题

所有通信都是单向的。

增加系统结构和实现的复杂性，只适合大型项目的开发。

view层和model之间存在耦合。



## 25. 真实 DOM与虚拟DOM

1. 定义：

Real DOM：真实 DOM，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实 DOM 结构。

Virtual Dom：虚拟DOM，虚拟 DOM（Virtual DOM）本质上是JS 和 DOM 之间的一个映射缓存，它在形态上表现为一个能够描述 DOM 结构及其属性信息的 JS 对象。它主要存储在内存中。

 

2. 目的：

创建虚拟 DOM 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 DOM 对象的节点与真实 DOM 的属性一一照应。



3. 区别：

​	虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘。

​	虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”。



​	例:传统的原生 api 或 jQuery 去操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。

​	当你在一次操作时，需要更新 10 个 DOM 节点，浏览器没这么智能，收到第一个更新 DOM 请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程。

​	而通过 VNode，同样更新 10 个 DOM 节点，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算。



4. **优缺点：**

真实 DOM 优势：易用。

缺点：

​	效率低，解析速度慢，内存占用量过高。

​	性能差：频繁操作真实 DOM，易于导致重绘与回流。

 

虚拟 DOM 优势：

​	简单方便：如果使用手动操作真实 DOM 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难。

​	性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能。

​	跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行。

缺点：

​	在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。

​	首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢。



5. 工作原理：

   1. 当底层数据变化时，整个ui都将在虚拟DOM描述中重新渲染。

   2. 然后计算旧虚拟DOM与新虚拟DOM之间的差异。

   3. 完成计算后，只将实际更改的部分更新到真实DOM。



## 26. React路由

react路由分为三种:1.web 2.native 3.通用anywhere。

路由本质：页面的URL发生改变时，页面的显示结果可以根据URL的变化而变化，但是页面不会刷新。

作用：可以实现无刷新的条件下切换显示不同的页面。

为什么使用路由：react是单页应用（SPA），需要通过路由跳转，不向服务器发送请求，性能优化。

多页面的跳转每次都向服务器请求新的页面，消耗性能，使用路由构建SPA单页面应用，项目中只有一个页面，所有的内容展示和业务处理都是在这个有一个页面中完成的，不但优化了性能，还解决了资源共享和信息通信问题。



react-router主要分成了几个不同的包：

​	react-router: 实现了路由的核心功能。

​	react-router-dom： 基于 react-router，具体实现浏览器相关的路由监听和跳转。

​	react-router-native：基于 react-router，具体实现react-native的路由监听和跳转。

​	react-router-config: 用于配置静态路由的工具库。



switch关键字？

​	switch标记会按顺序将已定义的路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。



优点：

​	配置灵活。

​	支持丰富的传参。

​	利用hashRouter也可以实现低版本浏览器的兼容。

缺点：

​	v4之后使用url query的方式传参比较繁琐，解析时需要使用queryString和location.search。

​	利用react-router的query或state进行传参打开新的路由，刷新页面后数据会丢失。

​	BrowserRouter的模式需要服务器配合，保证在前端路由的切换范围内，都只相应同一个html文件。

​	BrowserRouter需要现代浏览器才能兼容。

 

路由模式：

​	hash 模式：在url后面加上#。hash 模式路由就是利用 hashchange 事件监听 URL 的变化。

​	history 模式：访问会话历史记录。





## 27. 构造函数中调用super(props)的目的

​	子类是没有自己的 this 的，它只能继承父类的 this ，然后对其进行加工，而 super() 就是将父类中的 this 继承给子类的，没有 super() 子类就得不到 this。



## 28. react怎么设置生产环境版本

​	通常情况下我们会使用Webpack的DefinePlugin方法来将NODE_ENV变量值设置为production。

​	编译版本中React会忽略propType验证以及其他的警告信息，移除不必要的注释等信息。

​	用TS写的源码，在实际应用到生产时已经被编译成了JS,源文件毫无用处，不需要包含进去，所以生产环境就排除掉TS文件以压缩体积，落实到node具体实现也有很多方法。

​	NODE_ENV最早是express(web框架)自己定的一个环境变量，通过设置不同的值以在生产和开发环境作出相应动作。



## 29. createElement与cloneElement区别

createElement函数是JSX编译之后使用的创建React Element的函数。

cloneElement则是用于复制某个元素。





## 30. React优化方案

​	虽然React凭借virtual DOM和diff算法拥有高效的性能，但是某些情况下，性能明显可以进一步提高。

​	例：类组件通过调用setState方法， 就会导致render，父组件一旦发生render渲染，子组件即使并没有发生任何改变，也会执行render渲染。

​	当更新一个子组件的时候，理想状态只调用该路径下的组件render，但是react的默认做法是调用所有组件的render，再对生成的虚拟DOM进行对比，不改变则不进行更新。

​	这是diff算法对比，明显的性能浪费的情况。



优化：

1. shouldComponentUpdate：

    通过shouldComponentUpdate生命周期函数来比对 state和 props，确定是否要重新渲染。

2. PureComponent：

​		跟shouldComponentUpdate原理基本一致，通过对 props 和 state的浅比较结果来实现 shouldComponentUpdate。

3. React.memo：

​		React.memo用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似。但不同的是， React.memo 只能用于函数组件。

4. 避免使用内联函数：

​		每次调用render函数时都会创建一个新的函数实例，应该在组件内部创建一个函数，并将事件绑定到该函数本身。这样每次调用 render 时就不会创建单独的函数实例。

5. 使用 Immutable：

​		为了避免重复渲染，我们会在shouldComponentUpdate()中做对比，当返回true执行render方法。

​		Immutable通过is方法则可以完成对比，而无需通过深度比较的方式比较。

6. 懒加载组件：

​		从工程方面考虑，webpack存在代码拆分能力，可以为应用创建多个包，并在运行时动态加载，减少初始包的大小，而在react中使用到了Suspense和 lazy组件实现代码拆分功能。

7. 事件绑定方式：

 	事件绑定

![image-20221220221428533](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220221428533.png)

​	上述的代码看似没有问题，但是当将处理函数输出代码换成console.log(this)的时候，点击按钮，则会发现控制台输出undefined。



在事件绑定方式中，我们了解到四种事件绑定的方式。

1. render方法中使用bind

![image-20221220221520746](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220221520746.png)

2. render方法中使用箭头函数

![image-20221220221706623](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220221706623.png)



3. constructor中bind

   在constructor中预先bind当前组件，可以避免在render操作中重复绑定

![image-20221220221749535](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220221749535.png)



4. 定义阶段使用箭头函数绑定：

![image-20221220221828348](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220221828348.png)



​	从性能方面考虑，在render方法中使用bind和render方法中使用箭头函数这两种形式在每次组件render的时候都会生成新的方法实例，性能欠缺。

​	而constructor中bind事件与定义阶段使用箭头函数绑定这两种形式只会生成一个方法实例，性能方面会有所改善。



通过上面初步学习，我们了解到react常见的性能优化可以分成三个层面：

​	代码层面、工程层面、框架机制层面。





## 31. Hooks介绍

概念：

​	React hooks是react16.8 以后，react新增的钩子API，目的是增加代码的可复用性，逻辑性，弥补无状态组件没有生命周期，没有数据管理状态state的缺陷。

解决什么？

​	没有 Hooks，函数组件能够做的只是接受 Props、渲染 UI ，以及触发父组件传过来的事件。所有的处理逻辑都要在类组件中写，这样会使 class 类组件内部错综复杂，每一个类组件都有一套独特的状态，相互之间不能复用。

​	类组件之间的状态会随着功能增强而变得越来越臃肿，代码维护成本也比较高，而且不利于后期 tree shaking。所以有必要做出一套函数组件代替类组件的方案，于是 Hooks 也就理所当然的诞生了。

 

所以 Hooks 出现本质上原因是：

1. 让函数组件也能做类组件的事，有自己的状态，可以处理一些副作用，能获取 ref ，也能做数据缓存。

2. 解决逻辑复用难的问题。

3. 通过自定义hook能够更好的封装我们的功能。

4. 编写hooks为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅。

 

为什么要使用自定义 Hooks ？

​	自定义 hooks 是在 React Hooks 基础上的一个拓展，可以根据业务需求制定满足业务需要的组合 hooks ，更注重的是逻辑单元。通过业务场景不同，到底需要React Hooks 做什么，怎么样把一段逻辑封装起来，做到复用，这是自定义 hooks 产生的初衷。

![image-20221220222114119](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220222114119.png)





### 1.useState

​	useState可以使函数组件像类组件一样拥有 state，函数组件通过 useState 可以让组件重新渲染，更新视图。

### 2.useReducer

​	useReducer 是 react-hooks 提供的能够在无状态组件中运行的类似redux的功能 api 。

### 3.useEffect

​	用于弥补函数组件没有生命周期的缺陷。模拟类组件中部分生命周期函数（componentDidMount，componentDidUpdata，componentWillUnmount）。

​	useEffect只有一个参数的时候（componentDidMount和componentDidUpdata）。

​	useEffect有两个参数的时候，第二个参数是空数组(componentDidMount) 。

​	useEffect有两个参数的时候，第二个参数数组中有值[依赖项]，只有依赖的数据发生变化才会触发。

​	return返回值componentWillUnmount。



参数：

​	useEffect 第一个参数 callback, 返回的 destory ， destory 作为下一次callback执行之前调用，用于清除上一次 callback 产生的副作用。

​	第二个参数作为依赖项，是一个数组，可以有多个依赖项，依赖项改变，执行上一次callback 返回的 destory ，和执行新的 effect 第一个参数 callback 。

​	对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会向 setTimeout回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。



功能：

① 请求数据。

② 设置定时器,延时器等。

③ 操作 dom , 在 React Native 中可以通过 ref 获取元素位置信息等内容。

④ 注册事件监听器, 事件绑定，在 React Native 中可以注册 NativeEventEmitter。

⑤ 还可以清除定时器，延时器，解绑事件监听器等。



### 4.useLayoutEffect

useLayoutEffect 和 useEffect 不同的地方是采用了同步执行，那么和useEffect有什么区别？

① 首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 DOM 信息，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect ，那 useEffect 执行是在浏览器绘制视图之后，接下来又改 DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。

② useLayoutEffect callback 中代码执行会阻塞浏览器绘制。



### 5.useContext

​	订阅并获取react context上下文，用于跨层级状态传递。

​	使用 useContext，来获取父级组件传递过来的 context 值，这个当前值就是最近的父级组件 Provider 设置的 value 值，useContext 参数一般是由 createContext 方式创建的 ,也可以父级上下文 context 传递的 ( 参数为 context )。useContext 可以代替 context.Consumer 来获取 Provider 中保存的 value 值。

![image-20221220234034866](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220234034866.png)



### 6.useRef

​	useRef 可以用来获取元素，缓存状态。



### 7.useImperativeHandle

​	useImperativeHandle 用于函数组件能被ref获取。

​	对于子组件是 class 类组件，我们可以通过 ref 获取类组件的实例，但是在子组件是函数组件的情况，不能直接通过 ref 的，那么此时 useImperativeHandle 和 forwardRef 配合就能达到效果。

useImperativeHandle 参数：

1. 第一个参数ref: 接受 forWardRef 传递过来的 ref。

2. 第二个参数 createHandle ：处理函数，返回值作为暴露给父组件的 ref 对象。

3. 第三个参数 deps : 依赖项 deps ，依赖项更改形成新的 ref 对象。

 

useImperativeHandle 基础用法：

我们来模拟给场景，用useImperativeHandle，使得父组件能让子组件中的input自动赋值并聚焦。

![image-20221220235700751](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220235700751.png)



### 8.useMemo

​	派生并缓存新的状态，用于性能优化使用。

​	useMemo 可以在函数组件 render 上下文中同步执行一个函数逻辑，这个函数的返回值可以作为一个新的状态缓存起来。



​	场景一：在一些场景下，需要在函数组件中进行大量的逻辑计算，那么我们不期望每一次函数组件渲染都执行这些复杂的计算逻辑，所以就需要在 useMemo 的回调函数中执行这些逻辑，然后把得到的产物（计算结果）缓存起来就可以了。

 

useMemo 基础介绍：

const cacheSomething = useMemo(callback,deps)

① callback：第一个参数为一个函数，函数的返回值作为缓存值。

② deps： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，有改变重新执行 callback，得到新的缓存值。

③ cacheSomething：返回值，执行 callback的返回值。deps 中有依赖项改变，返回的重新执行 callback产生的值，否则取上一次缓存值。



### 9.useCallback

​	缓存状态常用于缓存提供给子代组件的callback回调函数。

​	useCallback 基础介绍：

​		useMemo 和 useCallback 接收的参数都是一样，都是在其依赖项发生变化后才执行，都是返回缓存的值，区别在于 useMemo 返回的是函数运行的结果，useCallback 返回的是函数。

​		这个回调函数是经过处理后的也就是说父组件传递一个函数给子组件的时候，由于是无状态组件每一次都会重新生成新的 props 函数，这样就使得每一次传递给子组件的函数都发生了变化，这时候就会触发子组件的更新，这些更新是没有必要的。

​		此时我们就可以通过 useCallback来处理此函数，然后作为 props 传递给子组件。



useCallback 基础用法：

![image-20221220235939658](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221220235939658.png)



## 32. react的渲染过程中兄弟节点之间是怎么处理的也就是key值不一样时

首先必须给每一个节点添加key，添加一个身份标识。方便react在重渲染过程中进行识别。

当key一样，组件属性有所变化则react只更新组件对应的属性，没有变化则不更。

当key不一样，react则先销毁该组件然后重新创建该组件。



## 33. react-router里的Link标签和a标签区别

​	在使用react-router时候，我们常常会使用其自带的路径跳转组件Link,通过<Link to="path">。对比a标签，Link组件避免了不必要的重渲染。区别表象体现在是否有主文档请求，<a>标签一定会出现，而Link则是通常不出现。



## 34. Time Slicing时间切片

​	根据W3C规范的介绍，超过50ms的任务就是长任务,当延迟超过100ms，用户就会察觉到轻微的延迟。

![image-20221221000207874](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221221000207874.png)

​	所以为了避免这种情况，我们可以使用两种方案，一种是Web Worker，另一种是时间切片（Time Slicing）。



时间切片概念：是一项使用得比较广的技术方案，它的本质就是将长任务分割为一个个执行时间很短的任务，然后再一个个地执行。



核心思想：任务不能在50毫秒内执行完，那么为了不阻塞主线程，这个任务应该让出主线程的控制权，使浏览器可以处理其他任务。让出控制权意味着停止执行当前任务，让浏览器去执行其他任务，随后再回来继续执行没有执行完的任务。



目的：不阻塞主线程。

 

实现：将一个长任务拆分成很多个不超过50ms的任务分散在宏任务队列中执行。

 

缺点：

​	任务运行的总时间变长了，这是因为它每处理完一个小任务后，主线程会空闲出来，并且在下一个小任务开始处理之前有一小段延迟。

​	但是为了避免卡死浏览器，这种取舍是很有必要的。



例：渲染长列表：

```html
<style>
	* {
		margin: 0;
		padding: 0;
	}

	.list {
		width: 60vw;
		position: absolute;
		left: 50%;
		transform: translateX(-50%);
	}
</style>
<ul class="list"></ul>
<script>
	function gen(task) {
		requestIdleCallback(deadline => {
			let next = task.next();
			while (!next.done) {
				if (deadline.timeRemaining() <= 0) {
					gen(task)
					return
				}
				next = task.next()
			}
		})
	}
	let list = document.querySelector('.list');
	let total = 100000;
	function* loop() {
		for (let i = 0; i < total; ++i) {
			let item = document.createElement('li')
			item.innerText = `我是${i}`
			list.appendChild(item)
			yield
		}
	}
</script>
```





## 35.React中fiber的理解

从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写。

从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的"虚拟 DOM"。

一个 fiber 就是一个 JavaScript 对象：

```js
type Fiber = {
  // 用于标记fiber的WorkTag类型，主要表示当前fiber代表的组件类型如FunctionComponent、ClassComponent等
  tag: WorkTag,
  // ReactElement里面的key
  key: null | string,
  // ReactElement.type，调用`createElement`的第一个参数
  elementType: any,
  // The resolved function/class/ associated with this fiber.
  // 表示当前代表的节点类型
  type: any,
  // 表示当前FiberNode对应的element组件实例
  stateNode: any,

  // 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回
  return: Fiber | null,
  // 指向自己的第一个子节点
  child: Fiber | null,
  // 指向自己的兄弟结构，兄弟节点的return指向同一个父节点
  sibling: Fiber | null,
  index: number,

  ref: null | (((handle: mixed) => void) & { _stringRef: ?string }) | RefObject,

  // 当前处理过程中的组件props对象
  pendingProps: any,
  // 上一次渲染完成之后的props
  memoizedProps: any,

  // 该Fiber对应的组件产生的Update会存放在这个队列里面
  updateQueue: UpdateQueue<any> | null,

  // 上一次渲染的时候的state
  memoizedState: any,

  // 一个列表，存放这个Fiber依赖的context
  firstContextDependency: ContextDependency<mixed> | null,

  mode: TypeOfMode,

  // Effect
  // 用来记录Side Effect
  effectTag: SideEffectTag,

  // 单链表用来快速查找下一个side effect
  nextEffect: Fiber | null,

  // 子树中第一个side effect
  firstEffect: Fiber | null,
  // 子树中最后一个side effect
  lastEffect: Fiber | null,

  // 代表任务在未来的哪个时间点应该被完成，之后版本改名为 lanes
  expirationTime: ExpirationTime,

  // 快速确定子树中是否有不在等待的变化
  childExpirationTime: ExpirationTime,

  // fiber的版本池，即记录fiber更新过程，便于恢复
  alternate: Fiber | null,
}
```



**Fiber 如何解决问题的**

​	Fiber 把一个渲染任务分解为多个渲染任务，而不是一次性完成，把每一个分割得很细的任务视作一个"执行单元"，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，故任务会被分散到多个帧里面，中间可以返回至主进程控制执行其他任务，最终实现更流畅的用户体验。

​	即是实现了"增量渲染"，实现了可中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber 节点。

​	**架构的核心即是"可中断"、"可恢复"、"优先级"**



## 36.react路由懒加载

**使用React.lazy和Suspense**

React利用React.lazy与import()实现了渲染时的动态加载

利用Suspense来处理异步加载资源时页面应该如何显示的问题

通过lazy()api来动态import需要懒加载的组件

Import的组件目前只支持export default的形式导出

Suspense来包裹懒加载的组件进行加载，可以设置fallback实现加载的效果

React.lazy可以结合Router来对模块进行懒加载。



## 37.react函数组件，在父组件调用子组件的属性和方法

useImperativeHandle 应当与 forwardRef 一起使用，useImperativeHandle：将ref的实例传递给父组件。

父组件：

```jsx
import React,{useRef} from 'react';
import FancyInput from './Child';

export default function App() {
	const fanRef= React.useRef();
	
	// 在这里调用子组件的实例方法。
	function handleClick(){
		fanRef.current.focus();
		fanRef.current.test();
	};

	return (
		<div>
			<FancyInput ref={fanRef}/>
			<button onClick={handleClick}>
        		Focus the input
     		</button>
		</div>
	)
}
```

子组件：

```jsx
import React, { useRef, useImperativeHandle } from 'react';

const FancyInput = React.forwardRef((props, ref) => {
  const inputRef = useRef();
    
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
	test:() => {
		console.log('test');
	}
  }));
    
  return <input ref={inputRef} />;
});

export default FancyInput;
```



## 38.为什么使用路由

​	多页面的跳转每次都向服务器请求新的页面，消耗性能，使用路由构建SPA单页面应用，项目中只有一个页面，所有的内容展示和业务处理都是在这个有一个页面中完成的，不但优化了性能，还解决了资源共享和信息通信问题。







# 二、Vue



## 1. v-if 和 v-show区别

共同点：

​	都能控制元素的显示和隐藏，当表达式为true时都会占据页面位置，当为false时都不会占据页面位置。



不同点：

​	控制手段不同：v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除。

​	编译过程不同：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换。

​	v-show 由false变为true的时候不会触发组件的生命周期。

​	v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法。



​	性能消耗：频繁切换某节点，使用V-show(切换开销比较小，初始开销较大)，不需要频繁切换某节点使用V-if(初始渲染开销较小，切换开销比较大)。



## 2. v-if 和 v-for优先级

1. vue2里面v-for优先级更高。因为vue2在模板编译的时候会先处理v-for再处理v-if，所以生成的渲染函数会先执行循环，然后在循环里面再执行条件判断，浪费了性能。
2. vue2中怎么避免：
   1. 在外层嵌套template，在这一层进行v-if条件判断，然后在内部进行循环。
   2. 当条件出现在循环内部，可以用计算属性过滤掉不需要的项。
3. vue3中v-if优先级更高。



## 3. vue组件data为什么必须是函数

​	JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。

​	而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰，这都是因为js特性带来的，根vue本身设计无关。

​	所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。



## 4. Vuex

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7b77fdcf29d410eb74f4872dd9c82fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 是什么：

​	它是一个程序里面的**状态管理模式**，它是**集中式**存储**所有**组件的状态的小仓库，并且保持我们存储的状态以一种**可以预测**的方式发生变化。



### 五大属性：

state：存放状态。

mutations：对state状态进行同步修改操作。

getters：获取state数据，类似于计算属性。

actions：进行一步操作，异步给到的结果通知mutations更改state。

modules：模块化，namespace开启命名空间。



### actions和mutation的区别

actions

1. 用于通过提交mutation改变数据
2. 会默认将自身封装为一个Promise
3. 可以包含异步任务

mutation

1. 通过提交commit改变数据
2. 只是一个单纯的函数
3. 不能使用异步操作，异步会导致变量不能追踪



### 异步修改数据

​	**过程：**Vue组件通过 dispatch() 通知 actions 和API交互，得到数据，actions通过commit()通知mutations修改state数据，数据设置完成后，state响应式让组件重新渲染。

```js
const store = new Vuex.Store({
  state: {
    name: '张三',
    number: 0,
  },
  mutations: {
    setNumberIsWhat(state, payload) {
      state.number = payload.number;
    },
  },
  actions: {
    // 增加actions属性
    setNum(content，num) {
      // 增加setNum方法，默认第一个参数是content，其值是复制的一份store
      return new Promise(resolve => {
        // 我们模拟一个异步操作，1秒后修改number为888
        setTimeout(() => {
          content.commit('setNumberIsWhat', { number: num });
          resolve();
        }, 1000);
      });
    },
  },
});
```



### 优势：

1. vuex集中管理共享数据，便于开发和后期维护。
2. 高效的实现组件间的数据共享，提高开发效率。





## 5. vue组件通讯方式

- 父子组件间通讯
- 兄弟组件间通讯
- 隔代组件间通讯
- 无相关组件间通讯



### 1.props和$emit

​	这种方式通常用于父子组件之间的传值，父组件通过属性的方式将值传递给子组件，子组件通过props进行接收。子组件通过事件的方式向父组件传递数据。



**1.1 父组件传值给子组件**

​	接下来我们利用属性方式从父组件传递值给子组件。

```vue
// src/views/parent.vue
<template>
  <div class="parent-box">
    <p>父级组件</p>
    <div>
      <button @click="changeMsg">更改数据</button>
    </div>
    <child1 :msg="msg"></child1>
    <child2 :msg="msg"></child2>
  </div>
</template>
<script>
import child1 from "./child1.vue";
import child2 from "./child2.vue";
export default {
  data() {
    return {
      msg: "我是父组件的数据",
    };
  },
  components: {
    child1,
    child2,
  },
  methods: {
    // 点击按钮更改数据
    changeMsg() {
      this.msg = "变成小猪课堂";
    },
  },
};
</script>
```

​	子组件接收参数：

```vue
// src/views/child1.vue
<template>
  <div class="child-1">
    <p>child1组件</p>
    <div>
      <p>parent组件数据：{{ msg }}</p>
    </div>
  </div>
</template>
<script>
export default {
  props: {
    msg: {
      type: String,
      default: "",
    },
  },
};
</script>
```



**1.2 子组件给父组件传值**

​	子组件可以通过$emit自定义事件的方式向父组件传递值，父组件需要监听该事件来进行接收子组件传来的值。

父组件代码：

```vue
// src/views/parent.vue
<template>
  <div class="parent-box">
    <p>父级组件</p>
    <div>
      <button @click="changeMsg">更改数据</button>
    </div>
    <div>子组件数据：{{ childData }}</div>
    <child1 :msg="msg" @childData="childData"></child1>
    <child2 :msg="msg"></child2>
  </div>
</template>
<script>
import child1 from "./child1.vue";
import child2 from "./child2.vue";
export default {
  data() {
    return {
      msg: "我是父组件的数据",
      childData: "",
    };
  },
  components: {
    child1,
    child2,
  },
  methods: {
    changeMsg() {
      this.msg = "变成小猪课堂";
    },
    // 监听子组件事件
    childData(data) {
      this.childData = data;
    },
  },
};
</script>
```

子组件代码：

```vue
// src/views/child1.vue
<template>
  <div class="child-1">
    <p>child1组件</p>
    <div>
      <button @click="sendData">传递数据给父组件</button>
    </div>
    <div>
      <p>parent组件数据：{{ msg }}</p>
    </div>
  </div>
</template>
<script>
export default {
  props: {
    msg: {
      type: String,
      default: "",
    },
  },
  methods: {
    // 点击按钮，使用$emit向父组件传递数据
    sendData() {
      this.$emit("childData", "我是子组件数据");
    },
  },
};
</script>
```



### 2.$parent获取父组件值

这种方式可以让子组件非常方便的获取父组件的值，不仅仅包括数据，还可以是方法。

子组件代码：

```vue
// src/views/child1.vue
<template>
  <div class="child-1">
    <p>child1组件</p>
    <div>
      <button @click="sendData">传递数据给父组件</button>
    </div>
    <div>
      <button @click="getParentData">使用$parent</button>
    </div>
    <div>
      <p>parent组件数据：{{ msg }}</p>
    </div>
  </div>
</template>
<script>
export default {
  props: {
    msg: {
      type: String,
      default: "",
    },
  },
  methods: {
    sendData() {
      this.$emit("childData", "我是子组件数据");
    },
    // 通过$parent方式获取父组件值
    getParentData() {
      console.log("父组件", this.$parent);
    },
  },
};
</script>
```





### 3.$children和$refs获取子组件值

这两种方式和$parent非常的类似，它们可以直接获取子组件的相关属性或方法，不仅限于数据。

父组件代码：

```vue
// src/views/parent.vue
<template>
  <div class="parent-box">
    <p>父级组件</p>
    <div>
      <button @click="changeMsg">更改数据</button>
    </div>
    <div>
      <button @click="getChildByRef">使用$children和$refs</button>
    </div>
    <div>子组件数据：{{ childData }}</div>
    <child1 ref="child1" :msg="msg" @childData="getChildData"></child1>
    <child2 :msg="msg"></child2>
  </div>
</template>
<script>
import child1 from "./child1.vue";
import child2 from "./child2.vue";
export default {
  data() {
    return {
      msg: "我是父组件的数据",
      childData: "",
    };
  },
  components: {
    child1,
    child2,
  },
  methods: {
    changeMsg() {
      this.msg = "变成小猪课堂";
    },
    // 监听子组件的自定义事件
    getChildData(data) {
      this.childData = data;
    },
    // 使用$chilren和$refs获取子组件
    getChildByRef() {
      console.log("使用$children", this.$children);
      console.log("使用$refs", this.$refs.child1);
    },
  },
};
</script>
```

​	children会返回当前组件所包含的所有子组件数组。

​	使用refs时，需要在子组件上添加ref属性，有点类似于直接获取DOM节点的操作。



### 4.使用$attrs和$listeners（多层组件）

​	$attrs通常在多层组件传递数据的时候使用。遇到多层组件数据传递的场景，他可能会直接选用Vuex进行传递，但是如果我们需要传递的数据没有涉及到数据的更新和修改时，建议使用$arrts的方式，毕竟Vuex还是比较重。



**$attrs定义：**

​	当父组件传递了很多数据给子组件时，子组件没有声明props来进行接收，那么子组件中的attrs属性就包含了所有父组件传来的数据(除开已经props声明了的)，子组件还可以使用v−bind="attrs"的形式向它的子组件（孙子组件）传递数据，孙子组件使用$attrs的方式和它的父组件原理类似。



**$attrs使用：**

父组件实例代码：

```vue
// src/views/parent.vue
<template>
  <div class="parent-box">
    <p>父级组件</p>
    <child1
      ref="child1"
      :msg="msg"
      :msg1="msg1"
      :msg2="msg2"
      :msg3="msg3"
      :msg4="msg4"
      @childData="getChildData"
    ></child1>
  </div>
</template>
<script>
import child1 from "./child1.vue";
export default {
  data() {
    return {
      msg: "我是父组件的数据",
      msg1: "parent数据1",
      msg2: "parent数据2",
      msg3: "parent数据3",
      msg4: "parent数据4",
      childData: "",
    };
  },
  components: { child1 }
};
</script>
```

子组件接收参数代码：

```vue
// src/views/child1.vue
<template>
  <div class="child-1">
    <p>child1组件</p>
    <!-- 子组件child1-child -->
    <child1-child v-bind="$attrs"></child1-child>
  </div>
</template>
<script>
import Child1Child from "./child1-child";
export default {
  components: {
    Child1Child,
  },
  props: {
    msg: {
      type: String,
      default: "",
    },
  },
  mounted() {
    console.log("child1组件获取$attrs", this.$attrs);
  }
};
</script>
```

child1-child组件示例代码

```vue
// src/views/child1-child.vue
<template>
  <div class="child1-child">
    <p>我是孙子组件child1-child</p>
  </div>
</template>
<script>
export default {
  props: {
    msg1: {
      type: String,
      default: "",
    },
  },
  mounted() {
    console.log("child1-child组件$attrs", this.$attrs);
  },
};
</script>
```



**$listeners 使用:**

​	listeners属性和listeners属性和attrs属性和类型，只是它们传递的东西不一样。

​	当父组件在子组件上定义了一些自定义的非原生事件时，在子组件内部可以通过$listeners属性获取到这些自定义事件。

​	它和attrs的区别很明显，$attrs用来传递属性，$listeners用来传递非原生事件，我们在child1组件中打印一下看看。



​	代码示例：

```vue
child1组件示例代码：
// src/views/child1.vue
<template>
  <div class="child-1">
    <p>child1组件</p>
    <div>
      <button @click="sendData">传递数据给父组件</button>
    </div>
    <div>
      <button @click="getParentData">使用$parent</button>
    </div>
    <div>
      <p>parent组件数据：{{ msg }}</p>
    </div>
    <!-- 子组件child1-child -->
    <child1-child v-bind="$attrs" v-on="$listeners"></child1-child>
  </div>
</template>


child1-child组件示例代码：
mounted() {
  console.log("child1-child组件$attrs", this.$attrs);
  console.log("child1-child组件$listerners", this.$listeners);
},
```

​	

​	使用listeners的好处在于：如果存在多层级组件，无需使用emit的方式逐级向上触发事件，只需要使用$listerners就可以得到父组件中的自定义事件，相当于偷懒了。



**inheritAttrs**

​	在使用$attrs时，child1子组件渲染的DOM节点上将我们传递的属性一起渲染了出来，如下图所示：

​	这并不是我们想要的，为了解决这个问题，我们可以在子组件中设置inheritAttrs属性。

![image-20221222141354520](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20221222141354520.png)



通俗解释：

​	父组件传递了很多数据给子组件，子组件的props没有完全接收，那么父组件传递的这些数据就会渲染到HTML上，我们可以给子组件设置inheritAttrs 为false，避免这样渲染。

child1组件代码示例：

```vue
// src/views/child1.vue
props: {
  msg: {
    type: String,
    default: "",
  },
},
inheritAttrs: false,
```



**总结**

- $attrs：用来传递属性，出了class、style之类的，它是一个对象。
- $listeners：用来传递事件，出了原生事件，它也是一个对象。
- attrs和attrs和attrs和listeners这两个属性可以解决多层组件之间数据和事件传递的问题。
- inheritAttrs解决未使用props接收的数据的属性渲染。





### 5.自定义事件：事件总线

​	事件中心实现数据传递的这种方式，其实就是一个发布者和订阅者的模式，这种方式可以实现任何组件之间的通信。

​	事件中心主要就两个作用：**触发事件和监听事件**。

main.js代码：

```js
// src/main.js
Vue.config.productionTip = false
Vue.prototype.$EventBus = new Vue()
new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')
```



组件1代码：

```vue
<template>
  <div class="child-1">
    <p>child1组件</p>
    <div>
      <button @click="toChild2">向child2组件发送数据</button>
    </div>
  </div>
</template>
<script>
import Child1Child from "./child1-child";
export default {
  methods: {
    // 通过事件总线向child2组件发送数据
    toChild2() {
      this.$EventBus.$emit("sendMsg", "我是child1组件发来的数据");
    },
  },
};
</script>
```



组件2代码：

```vue
// src/views/child1.vue
<template>
  <div class="child-2">
    <p>child2组件</p>
    <div>
      <p>parent组件数据：{{ msg }}</p>
    </div>
  </div>
</template>
<script>
export default {
  props: {
    msg: {
      type: String,
      default: "",
    },
  },
  mounted() {
    this.$EventBus.$on("sendMsg", (msg) => {
      console.log("接收到child1发送来的数据", msg);
    });
  },
};
</script>
```



### 6.provide和inject

​	provide和inject需要在一起使用。

​	父组件可以向子组件（无论层级）注入依赖，每个子组件都可以获得这个依赖，无论层级。



parent代码示例：

```vue
// src/views/parent.vue
<script>
import child1 from "./child1.vue";
import child2 from "./child2.vue";
export default {
  provide() {
    return { parentData: this.msg };
  },
  data() {
    return {
      msg: "我是父组件的数据",
      msg1: "parent数据1",
      msg2: "parent数据2",
      msg3: "parent数据3",
      msg4: "parent数据4",
      childData: "",
    };
  },
  components: {
    child1,
    child2,
  },
};
</script>
```



child代码示例：

```vue
// src/views/child1-child.vue
<template>
  <div class="child1-child">
    <p>我是孙子组件child1-child</p>
    <p>parent组件数据：{{parentData}}</p>
  </div>
</template>
<script>
export default {
  inject: ["parentData"],
  props: {
    msg1: {
      type: String,
      default: "",
    },
  },
  mounted() {
    console.log("child1-child组件$attrs", this.$attrs);
    console.log("child1-child组件$listerners", this.$listeners);
    console.log("child1-child组件获取parent组件数据", this.parentData)
  },
};
</script>
```

​	**但此时数据不是响应式，也就是parent组件更改了数据，child1-child组件中的数据不会更新。**	

​	**需要改变一下provide传递的方式**。

parent代码示例：

```vue
// src/views/parent.vue
<script>
import child1 from "./child1.vue";
import child2 from "./child2.vue";
export default {
  provide() {
    return { parentData: this.getMsg };
  },
  data() {
    return {
      msg: "我是父组件的数据",
      msg1: "parent数据1",
      msg2: "parent数据2",
      msg3: "parent数据3",
      msg4: "parent数据4",
      childData: "",
    };
  },
  components: {
    child1,
    child2,
  },
  methods: {
    // 返回data数据
    getMsg() {
      return this.msg;
    },
  },
};
</script>
```



### 7.vuex和localstorage

**Vuex：**

- Vuex是状态管理器，它存储的数据不是持久化存储，一旦刷新页面或者关闭项目数据便不见了。
- Vuex存储的数据是响应式的。

**localstorage：**

- loacalStorage是HTML5中的一种数据存储方式，持久化存储，存储的数据不是响应式的。



### 8.v-model

​	通常用在表单元素上以此来实现数据的双向绑定，它的本质是v-on和v-bind的语法糖。在这里我们也可以借助它来实现某些场景下的数据传递。注意，这儿的场景必须是父子组件。



parent代码示例：

```vue
<template>
  <div class="parent-box">
    <p>父级组件</p>
    <div>modelData： {{modelData}}</div>
    <child2 :msg="msg" v-model="modelData"></child2>
    <!-- 实际等同于 -->
    <!-- <child2 v-bind:value="modelData" v-on:input="modelData=$event"></child2>  -->
  </div>
</template>
<script>
import child2 from "./child2.vue";
export default {
  provide() {
    return { parentData: this.getMsg };
  },
  data() {
    return {
      modelData: "parent组件的model数据"
    };
  },
  components: {
    child1,
  },
};
</script>
```



child2代码示例：

```vue
<template>
  <div class="child-2">
    <p>child2组件</p>
    <div>
      <button @click="confirm">修改v-model数据</button>
    </div>
  </div>
</template>
<script>
export default {
  props: {
    value: {
      type: String,
      default: "",
    },
  },
  mounted() {
    console.log("child2组件接收附件见v-model传递的数据", this.value);
  },
  methods: {
    // 通过$emit触发父组件的input事件，并将第二个参数作为值传递给父组件
    confirm() {
      this.$emit("input", "修改parent传递的v-model数据");
    },
  },
};
</script>
```

​	我们在父组件中使用v-model向child2子组件传递数据，子组件的props中使用默认的value属性接收，在子组件中利用$emit触发父组件中默认input事件，此时传递的数据便会在子组件和父组件中发生变化，这就是数据双向绑定。



### 总结：

父子组件间通讯：props和emit、parent、refs和children、v-model
兄弟组件间通讯：事件总线、Vuex、localStorage
隔代组件间通讯：provide和inject
无相关组件间通讯：事件总线、Vuex、localStorage





## 6. Vue响应式原理

**Vue检测数据改变的原理（核心是set）**

数据代理：在vm中写的data数据，vm会加工到 _data里，然后再拿出 _data里的数据到vm上。

加工一下（给每个数据添上get、set）就能做响应式了（数据变化页面跟着变化）。

流程：当data里name数据改变时，set调用，set调用后数据变化，然后重新解析模板，重新生成新的虚拟dom，新旧dom一对比，然后更新页面。



**是Vue的核心特性之一，数据驱动视图，我们修改数据视图随之响应更新**

1. vue.js则是采用数据劫持结合发布者-订阅者模式的方式。
3. Vue2.x是借助Object.defineProperty()来劫持各个属性的 setter，getter 实现的。

```js
Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    //拦截get，当我们访问data.key时会被这个方法拦截到
    get: function getter () {
        //我们在这里收集依赖
        return obj[key];
    },
    //拦截set，当我们为data.key赋值时会被这个方法拦截到
    set: function setter (newVal) {
        //当数据变更时，通知依赖项变更UI
    } 
})
```

​	3.x的与2.x的核心思想一致，只不过数据的劫持使用`Proxy`而不是`Object.defineProperty`，Proxy相比Object.defineProperty在处理数组和新增属性的响应式处理上更加方便。



缺点：

​	vue2的defineProperty在对一些属性进行操作时，使用这种方法无法拦截，比如通过**下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染**，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，**解决方法：使用this.$set() this.$delete()。**

​	在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用**Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题**，因为 Proxy 是 ES6 的语法。



## 7. Vue双向数据绑定实现

​	双向数据绑定通常是指我们使用的v-model指令的实现，是Vue的一个特性，也可以说是一个input事件和value的语法糖。 Vue通过v-model指令为组件添加上input事件处理和value属性的赋值。

​	因此当我们修改input输入框中的值时，我们通过v-model绑定的值也会同步修改，基于上述原理，我们可以很容易的实现一个数据双向绑定的组件。



## 8.单页面应用和多页面应用区别

​	单页面应用(SPA)：

​		通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的htm1,js,css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写(页面片段)，然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。

​	多页面(MPA)：

​		多个独立页面的应用（html），页面跳转时是整页刷新。

​		与 `SPA` 对比最大的不同即是页面路由切换由原生浏览器文档跳转（`navigating across documents`）控制。 页面跳转，是返回 HTML 的。	



单页面优点：

1. 页面切换快：

   ​	页面每次切换跳转时，并不需要做`html`文件的请求，这样就节约了很多`http`发送时延，我们在切换页面的时候速度很快。

2. 用户体验好：

​			页面片段间的切换快，包括移动设备, 尤其是在网络环境差的时候, 因为组件已经预先加载好了, 并不需要发送网络请求, 所以用户体验好。

单页面缺点：

 1. 首屏加载速度慢。

 2. 不易于SEO

    ​	SEO效果差，因为搜索引擎只认识`html`里的内容，不认识`js`的内容，而单页应用的内容都是靠js渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致SPA应用做出来的网页在百度和谷歌上的排名差。

3. 页面复杂度提高很多。



多页面优点：

1. 首屏加载速度快

当我们访问页面的时候，服务器返回一个`html`，页面就会展示出来，这个过程只经历了一个`HTTP`请求，所以页面展示的速度非常快。

2. SEO效果好

搜索引擎在做网页排名的时候，要根据网页的内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别`html`内容的，而我们每个页面所有的内容都放在`html`中，所以这种多页应用SEO排名效果好。



多页面缺点：

1. 页面切换慢

因为每次跳转都需要发送一个 HTTP 请求，如果网络状态不好，在页面之间来回跳转时，就会发生明显的卡顿，影响用户体验。

2. 用户体验不佳

如果网络慢,页面很容易半天加载不出来,用户体验非常不好。





## 9.Vue事件修饰符

**1.lazy**

​	作用：改变输入框的值时value不会改变，光标离开输入框时，v-model绑定的值value才会改变。

```vue
<input type="text" v-model.lazy="value">
<div>{{value}}</div>

data() {
        return {
            value: '222'
        }
    }
```

**2.trim**

​	作用：类似于js中trim（）的作用，作用是把v-model绑定的值的首尾空格过滤。

```vue
<input type="text" v-model.trim="value">
<div>{{value}}</div>

data() {
        return {
            value: '222'
        }
    }
```

**3.number**

​	作用：将值转成数字，但先输入字符串和先输入数字是两种情况。

​				先输入数字，只取前面数字部分。

​				先输入字母的话，`number`修饰符无效。

```vue
<input type="text" v-model.number="value">
<div>{{value}}</div>

data() {
        return {
            value: '222'
        }
    }
```

**4.stop**

​	作用：阻止冒泡。

```vue
<div @click="clickEvent(2)" style="width:300px;height:100px;background:red">
    <button @click.stop="clickEvent(1)">点击</button>
</div>

methods: {
        clickEvent(num) {
            不加 stop 点击按钮输出 1 2
            加了 stop 点击按钮输出 1
            console.log(num)
        }
    }
```

**5.capture**

​	作用：是改变js默认的事件机制,事件默认是冒泡,capture功能是将冒泡改为捕获模式。

```vue
<div @click.capture="clickEvent(2)" style="width:300px;height:100px;background:red">
    <button @click="clickEvent(1)">点击</button>
</div>

methods: {
        clickEvent(num) {
            不加 capture 点击按钮输出 1 2
            加了 capture 点击按钮输出 2 1
            console.log(num)
        }
    }
```

**6.self**

​	作用：只有点击事件绑定的本身才会触发事件，如果接受到内部的冒泡事件传递信号触发,会忽略掉这个信号。

```vue
<div @click.self="clickEvent(2)"style="width:300px;height:100px;background:red">
    <button @click="clickEvent(1)">点击</button>
</div>

methods: {
        clickEvent(num) {
            不加 self 点击按钮输出 1 2
            加了 self 点击按钮输出 1 点击div才会输出 2
            console.log(num)
        }
    }
```



**self和stop的区别：**

- **self只响应当前元素自身触发的事件，不会响应经过冒泡触发的事件，并不会阻止冒泡继续向外部触发。**
- **stop是从自身开始不向外部发射冒泡信号**。



**7.once**

​	作用：事件只执行一次。

```vue
<div @click.once="clickEvent(2)" style="width:300px;height:100px;background:red">
    <button @click="clickEvent(1)">点击</button>
</div>

methods: {
        clickEvent(num) {
            不加 once 多次点击按钮输出 1
            加了 once 多次点击按钮只会输出一次 1 
            console.log(num)
        }
    }
```

**8.prevent**

​	作用：阻止默认事件。（a标签跳转、button[type="submit"] 等...）

```vue
<a href="#" @click.prevent="clickEvent(1)">点我</a>

methods: {
        clickEvent(num) {
            不加 prevent 点击a标签 先跳转然后输出 1
            加了 prevent 点击a标签 不会跳转只会输出 1
            console.log(num)
        }
    }
```

**9.native**

​	作用：native修饰符是加在自定义组件的事件上，保证事件能执行。

```vue
执行不了
<My-component @click="shout(3)"></My-component>

可以执行
<My-component @click.native="shout(3)"></My-component>
```

**10.left，right，middle**

​	作用：鼠标的左中右按键触发的事件。

```vue
<button @click.middle="clickEvent(1)"  @click.left="clickEvent(2)"  @click.right="clickEvent(3)">点我</button>

methods: {
        点击中键输出1
        点击左键输出2
        点击右键输出3
        clickEvent(num) {
            console.log(num)
        }
    }
```

**11.passive**

​	作用：这个修饰符会执行默认方法。

​		一般用在滚动监听，滚动事件的默认行为 (即滚动行为) 将会立即触发，而不会等待 onScroll 完成。这个 .passive 修饰符尤其能够提升移动端的性能。

​		**.passive 和 .prevent 不能一起使用:prevent 将会被忽略。**

```vue
<div @scroll.passive="onScroll">...</div>
```

**12.keyCode**

​	作用：键盘修饰符。

```
//普通键
.enter 
.tab
.delete //(捕获“删除”和“退格”键)
.space
.esc
.up
.down
.left
.right
//系统修饰键
.ctrl
.alt
.meta
.shift
```

**13.sync**

​	作用：当我们想要在`父组件`和`子组件`之间对某个属性值进行双向绑定时,有什么便捷的方式？是的只要`.sync`修饰符即可办到。

父组件：

```vue
<template>
  <div class="sync-parent">
    我是父组件: {{ text }}
    <Child :text.sync="text" />
  </div>
</template>

import Child from './child.vue'

export default {
  name: 'SyncParent',
  data () {
    return {
      text: 'parent'
    }
  },
  components: {
    Child,
  }
}
```

子组件：

```vue
<template>
  <div class="child">
    我是子组件: 
    <input type="text" v-model="value" @input="onInput">
  </div>
</template>

export default {
  name: 'child',
  props: {
    text: {
      type: String
    }
  },
  data () {
    return {
      value: this.text
    }
  },
  methods: {
    onInput () {
      // 注意这里，必须是update:xxx的形式xxx即属性prop
      this.$emit('update:text', this.value)
    }
  }
}
```





## 10.Vue的两个核心是什么

数据驱动，组件化开发。





## 11.Vue3.0有哪些新特性

Vue3.0亮点：

1. Performance：性能优化

2. Tree-shaking support：更好的摇树优化

3. Composition API：组合API

4. Fragment，Teleport，Suspense：新增的组件

5. Better TypeScript support：更好的TypeScript支持

6. Custom Renderer API：自定义渲染器

Vue3.0坑点：

解构丢失响应性



### 1.Tree-shaking

​		Vue3最重要的变化之一就是**更好的Tree-Shaking**，Tree-Shaking带来的bundle体积更小是显而易见的。在2.x版本中，很多函数都挂载在全局Vue对象上，比如nextTick、set等函数，因此虽然我们可能用不到，但打包时只要引入了vue这些全局函数仍然会打包进bundle中。

　　而在Vue3中，所有的API都通过ES6模块化的方式引入，这样就能让webpack或rollup等打包工具在打包时对没有用到API进行剔除，最小化bundle体积；

​		创建app实例方式从原来的`new Vue()`变为通过createApp函数进行创建。

```js
//src/main.js
import { createApp } from "vue";
import App from "./App.vue";
import router from "./router";

const app = createApp(App);
app.use(router).mount("#app");
```



### 2.Proxy

​	数据的劫持使用`Proxy`而不是`Object.defineProperty`，Proxy相比Object.defineProperty在处理数组和新增属性的响应式处理上更加方便。

​	在对一些属性进行操作时，使用这种方法无法拦截，比如通过**下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染**，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。

​	在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用**Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题**，因为 Proxy 是 ES6 的语法。



### 3.Virtual DOM重构

​	vdom的本质是一个抽象层，用javascript描述界面渲染成什么样子。react用jsx,没办法检测
出可以优化的动态代码，所以做时间分片，vue中足够快的话可以不用时间分片。

传统vdom的性能瓶颈：
	虽然Vue能够保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个Vdom树。**传统vdom的性能跟模版大小正相关，跟动态节点的数量无关。在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费。**jsx和手写的render function是完全动态的，过度的灵活性导致运行时可以用于优化的信息不足，那为什么不直接抛弃vdom呢？
	高级场景下手写render function获得更强的表达力。
	生成的代码更简洁。

兼容2.x
	vue的特点是底层为Virtual DOM,上层包含有大量静态信息的模版。为了兼容手写render function,最大化利用模版静态信息，**vue3.0采用了动静结合的解决方案，将vdom的操作颗粒度变小，每次触发更新不再以组件为单位进行遍历**，主要更改如下：

1. 将模版基于动态节点指令切割为嵌套的区块。
2. 每个区块内部的节点结构是固定的。
3. 每个区块只需要以一个Array追踪自身包含的动态节点。
4. vue3.0将vdom更新性能由与模版整体大小相关提升为与动态内容的数量相关。



### 4.Composition API

​	之前的2.x版本采用的是Options API（选项API），即官方定义好了写法：data、computed、methods，需要在哪里写就在哪里写，这样带来的问题就是随着功能增加，代码也越来复杂，我们看代码需要上下反复横跳。

​	而Composition API做的就是把同一功能的代码放到一起维护，这样我们需要维护一个功能点的时候，不用去关心其他的逻辑，只关注当前的功能；Composition API通过setup选项来组织代码：

​	（可以将`setup`中的功能进行提取分割成一个一个独立函数，每个函数还可以在不同的组件中进行逻辑复用）

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/673d8a48ec9d4256b2c86b2918e60bbe~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)	

##### 	4.1.setup

​		它是组件内使用Composition API的入口，执行时机是beforeCreate之前。

​		它接受两个参数：props（组件传入的属性）、context。

​	setup 中接受的`props`是响应式的， 当传入新的 props 时，会及时被更新。由于是响应式的， 所以**不可以使用 ES6 解构**，解构会消除它的响应式。 （响应式需要依赖a.b这种访问方式来触发proxy拦截，但是解构就相当于直接访问b了，所以就失去了响应性）。

​	setup接受的第二个参数`context`，setup中不能访问 Vue2 中最常用的`this`对象，所以`context`中就提供了`this`中最常用的三个属性：`attrs`、`slot` 和`emit`，分别对应 Vue2.x 中的 `$attr`属性、`slot`插槽 和`$emit`发射事件。并且这几个属性都是自动同步最新的值，所以我们每次使用拿到的都是最新值。



##### 	4.2.reactive、ref 与 toRefs

​	在 vue2.x 中， 定义数据都是在data中， 但是 Vue3.x 可以使用reactive和ref来进行数据定义。
​	reactive函数可以代理一个对象， 但是不能代理基本类型，例如字符串、数字、boolean 等。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a824567ade0246098c7f37526585b171~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)



​	上面的代码中，我们绑定到页面是通过user.name；这样写感觉很繁琐，我们能不能直接将user中的属性解构出来使用呢? 答案是不能直接对user进行结构， 这样会消除它的响应式， 这里就和上面我们说props不能使用 ES6 直接解构就呼应上了。那我们就想使用解构后的数据怎么办，解决办法就是使用toRefs。

​	toRefs 用于将一个 reactive 对象转化为属性全部为 ref 对象的普通对象。具体使用方式如下：

```vue
<template>
  <div class="homePage">
    <p>第 {{ year }} 年</p>
    <p>姓名： {{ nickname }}</p>
    <p>年龄： {{ age }}</p>
  </div>
</template>

<script>
import { defineComponent, reactive, ref, toRefs } from "vue";
export default defineComponent({
  setup() {
    const year = ref(0);
    const user = reactive({ nickname: "xiaofan", age: 26, gender: "女" });
    setInterval(() => {
      year.value++;
      user.age++;
    }, 1000);
    return {
      year,
      // 使用reRefs
      ...toRefs(user),
    };
  },
});
</script>
```



##### 	4.3.生命周期

​	从图中我们可以看到 Vue3.0 新增了`setup`，这个在前面我们也详细说了， 然后是将 Vue2.x 中的`beforeDestroy`名称变更成`beforeUnmount`; `destroyed` 表更为 `unmounted`，为了更加语义化。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de01e730e563406cbf3399861fa23aa4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

   上边生命周期图中并没包含全部的生命周期钩子， 还有其他的几个， 全部生命周期钩子：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eadd1ec0ac94343951ae2453cf41fce~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)



###  5.自定义hooks

​	封装一个实现加减的hook，这些「自定义 Hook」以 use 作为前缀，和普通的函数加以区分。 useCount.ts 实现：

```ts
import { ref, Ref, computed } from "vue";

type CountResultProps = {
  count: Ref<number>;
  multiple: Ref<number>;
  increase: (delta?: number) => void;
  decrease: (delta?: number) => void;
};

export default function useCount(initValue = 1): CountResultProps {
  const count = ref(initValue);

  const increase = (delta?: number): void => {
    if (typeof delta !== "undefined") {
      count.value += delta;
    } else {
      count.value += 1;
    }
  };
  const multiple = computed(() => count.value * 2);

  const decrease = (delta?: number): void => {
    if (typeof delta !== "undefined") {
      count.value -= delta;
    } else {
      count.value -= 1;
    }
  };

  return {
    count,
    multiple,
    increase,
    decrease,
  };
}
```

useCount的使用：

```ts
<template>
  <p>count: {{ count }}</p>
  <p>倍数： {{ multiple }}</p>
  <div>
    <button @click="increase()">加1</button>
    <button @click="decrease()">减一</button>
  </div>
</template>

<script lang="ts">
import useCount from "../hooks/useCount";
 setup() {
    const { count, multiple, increase, decrease } = useCount(10);
        return {
            count,
            multiple,
            increase,
            decrease,
        };
    },
</script>
```



### 6.Teleport

​	Teleport 是 Vue3.x 新推出的功能。Teleport 就像是哆啦 A 梦中的「任意门」，任意门的作用就是可以将人瞬间传送到另一个地方。

​	有了这个认识，我们再来看一下为什么需要用到 Teleport 的特性呢，看一个小例子：
​		在子组件Header中使用到Dialog组件，我们实际开发中经常会在类似的情形下使用到 Dialog ，此时Dialog就被渲染到一层层子组件内部，处理嵌套组件的定位、z-index和样式都变得困难。
​		Dialog从用户感知的层面，应该是一个独立的组件，从 dom 结构应该完全剥离 Vue 顶层组件挂载的 DOM；同时还可以使用到 Vue 组件内的状态（data或者props）的值。**简单来说就是,即希望继续在组件内部使用Dialog, 又希望渲染的 DOM 结构不嵌套在组件的 DOM 中。**
​		此时就需要 Teleport 上场，我们可以用<Teleport>包裹Dialog, 此时就建立了一个传送门，可以将Dialog渲染的内容传送到任何指定的地方。



 **Teleport 的使用方式：**

我们希望 Dialog 渲染的 dom 和顶层组件是兄弟节点关系, 首先在`index.html`文件中定义一个供挂载的元素:

```html
<body>
  <div id="app"></div>
  <div id="dialog"></div>
</body>
```

定义一个`Dialog`组件`Dialog.vue`, 留意 `to` 属性， 与上面的`id`选择器一致：

```vue
<template>
  <teleport to="#dialog">
    <div class="dialog">
      <div class="dialog_wrapper">
        <div class="dialog_header" v-if="title">
          <slot name="header">
            <span>{{ title }}</span>
          </slot>
        </div>
      </div>
      <div class="dialog_content">
        <slot></slot>
      </div>
      <div class="dialog_footer">
        <slot name="footer"></slot>
      </div>
    </div>
  </teleport>
</template>
```



DOM渲染效果：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/712e61d275cb4b7da5252bb9cd6d2afa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

可以看到，我们使用 teleport 组件，通过 to 属性，指定该组件渲染的位置与 <div id="app"></div> 同级，也就是在 body 下，但是 Dialog 的状态 dialogVisible 又是完全由内部 Vue 组件控制。



### 7.Suspense

​	Suspense是 Vue3.x 中新增的特性，**简单的说它只是一个带插槽的组件，只是它的插槽指定了`default` 和 `fallback` 两种状态。**

​	我们通过 Vue2.x 中的一些场景来认识它的作用。 Vue2.x 中应该经常遇到这样的场景：

```vue
<template>
<div>
    <div v-if="!loading">
        ...
    </div>
    <div v-if="loading">
        加载中...
    </div>
</div>
</template>
```

​	在前后端交互获取数据时， 是一个异步过程，一般我们都会提供一个加载中的动画，当数据返回时配合v-if来控制数据显示。
​	如果你使用过vue-async-manager这个插件来完成上面的需求， 你对Suspense可能不会陌生，Vue3.x 感觉就是参考了vue-async-manager。

​	Vue3新出的内置组件Suspense, **它提供两个template slot, 刚开始会渲染一个 fallback 状态下的内容， 直到到达某个条件后才会渲染 default 状态的正式内容，**通过使用Suspense组件**展示异步渲染就更加的简单。**

​	**Suspense 组件的使用：**

```vue
  <Suspense>
        <template #default>
            <async-component></async-component>
        </template>
        <template #fallback>
            <div>
                Loading...
            </div>
        </template>
  </Suspense>
```

​	**asyncComponent.vue：**

```vue
<<template>
<div>
    <h4>这个是一个异步加载数据</h4>
    <p>用户名：{{user.nickname}}</p>
    <p>年龄：{{user.age}}</p>
</div>
</template>

<script>
import { defineComponent } from "vue"
import axios from "axios"
export default defineComponent({
    setup(){
        const rawData = await axios.get("http://xxx.xinp.cn/user")
        return {
            user: rawData.data
        }
    }
})
</script>
```



### 8.自定义指令

首先看vue2中的自定义指令：

```js
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
```

在 Vue 2 中， 自定义指令通过以下几个可选钩子创建：

- bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
- inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
- update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。
- componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。
- unbind：只调用一次，指令与元素解绑时调用。

**在 Vue 3 中对自定义指令的 API 进行了更加语义化的修改， 就如组件生命周期变更一样， 都是为了更好的语义**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a85dca78e2f4efcab61b03c98ec80de~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

在 Vue3 中， 可以这样来自定义指令：

```js
const { createApp } from "vue"

const app = createApp({})
app.directive('focus', {
    mounted(el) {
        el.focus()
    }
})
```



  

## 12.Vue性能优化方法

### 一、代码层面的优化

1. **v-if和v-show区分使用场景：**

   ​	v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。

2. **computed和watch区分使用场景：**

   computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；

   watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

   **运用场景：**

   - **当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed**，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
   - **当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch**，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

3. **v-for时添加key值，方便Vue内部机制精准找到该条数据，当数据更新时，新旧状态值对比，较快的定位到diff。并且避免同时使用v-for和v-if。**

   

4. 长列表性能优化

   **1. 不做响应式：使用Object.freeze冻结对象**

   ​	Vue2会通过Object.defineProperty对数据进行劫持，来实现响应式，然而有时候仅仅是为了展示数据，不会改变，这时候在大量数据展示的情况下，初始化时间久，可以使用Object.freeze方法来冻结一个对象，使其不能被修改，可以禁止Vue劫持数据，减少组件初始化的时间。

```js
xxxxxxxxxx export default {  data: () => ({    users: {}  }),  async created() {    const users = await axios.get("/api/users");    this.users = Object.freeze(users);  }};	
```

​	或者自定义option，写在和data同级，再使用 $options.xxx获取
​	或者干脆就写在外面，或者通过引入的方式，也没有响应式

​		**2. 虚拟滚动**

​		如果是大数据很长的列表，全部渲染的话一次性创建太多 DOM 就会非常卡，这时就可以用虚拟滚动，只渲染少部分(含可视区域)区域的内容，然后滚动的时候，不断替换可视区域的内容，模拟出滚动的效果。

​		参考 vue-virtual-scroller、vue-virtual-scroll-list。

​	https://github.com/tangbc/vue-virtual-scroll-list

​	原理是监听滚动事件，动态更新需要显示的 DOM，并计算出在视图中的位移，这也意味着在滚动过程需要实时计算，有一定成本，所以如果数据量不是很大的情况下，用普通的滚动就行。



5. **事件的销毁：**

   ​	Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListener 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露。

6. **图片资源懒加载：**

   ​    对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：

​		（1）安装vue-lazyload

​				npm install vue-lazyload --save-dev

​		（2）main.js文件使用

```js
import VueLazyload from 'vue-lazyload'

//然后在VUE中直接使用
Vue.use(VueLazyload)
```

​		（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：

```html
<img v-lazy="/static/img/1.png">
```



7. **路由懒加载、组件懒加载：**

   ES 提出的import方法

   方法如下：`const HelloWorld = （）=>import('需要加载的模块地址')` 

8. 第三方插件的按需引入。

9. 优化无线列表性能：

   ​	如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 你可以参考以下开源项目 [vue-virtual-scroll-list](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftangbc%2Fvue-virtual-scroll-list) 和 [vue-virtual-scroller](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAkryum%2Fvue-virtual-scroller)  来优化这种无限列表的场景的。

10. 服务端渲染ssr 和 预渲染：

    ​    服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。

​			服务端渲染优缺点：

​			优点：

​			（1）更好地SEO：

​	因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

​			（2）首屏加载更快：

​	SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

​			缺点：更多的开发条件限制、更多的服务器负载。

总结：

​	如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO。如果你的 Vue 项目只需改善少数营销页面（例如  `/， /about， /contac`t 等）的 SEO，那么你可能需要**预渲染**，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 [prerender-spa-plugin](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchrisvfritz%2Fprerender-spa-plugin) 就可以轻松地添加预渲染 。



11. **骨架屏**



### 二、Webpack层面的优化



### 三、基础的Web技术优化

1. 开启gzip压缩：

   ​	gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右

   ​	以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下：

   ```js
   //安装
   npm install compression --save
   
   //添加代码逻辑
   var compression = require('compression');
   var app = express();
   app.use(compression())
   ```

   重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功 ：

![1.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/15/16c924653ef48d24~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

2. 浏览器缓存：

3. 使用 Chrome Performance 查找性能瓶颈：
       Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。

   1. 打开 Chrome 开发者工具，切换到 Performance 面板
   2. 点击 Record 开始录制
   3. 刷新页面或展开某个节点
   4. 点击 Stop 停止录制

   



## 13.v-model原理

​	v-model即可以用作表单元素，也可以用于自定义组件，无论那一种情况，**它的本质都是一个语法糖，最终会生成一个属性(props)和一个事件(event)，帮助减少了代码量。**

​	当其作用与表单元素时，vue**会根据作用表单元素的类型而生成合适的属性和事件**，例：

1. text 和 textarea 元素使用 `value` 属性 和 `input` 事件；

2. checkbox 和 radio 使用 `checked` 属性 和 `change` 事件；

3. select 字段将 `value` 作为 prop 并将 `change` 作为事件。



vue2和vue3v-model区别：

​	1. .sync修饰符在vue3去掉了，它的功能可以由v-model的参数代替。

例：

```vue
<!-- vue2 -->
<Comp :title="inputVal" @update:title="inputVal = $event" />
<!-- 简写为 -->
<Comp :title.sync="inputVal" />

<!-- vue3 -->
<Comp :title="inputVal" @update:title="inputVal = $event" />
<!-- 简写为 -->
<Comp v-model:title="inputVal" />
```

2. 多个v-model（vue3）：

```vue
<ChildComponent v-model:title="pageTitle" v-model:content="pageContent" />

<!-- 是以下的简写： -->

<ChildComponent
  :title="pageTitle"
  @update:title="pageTitle = $event"
  :content="pageContent"
  @update:content="pageContent = $event"
/>
```



## 14.nextTick的实现原理

​	作用：nextTick 作用是在下次 DOM 更新循环结束之后，执行延迟回调，就可以拿到更新后的 DOM 相关信息。

### JS 执行机制

​	我们都知道 JS 是单线程的，一次只能干一件事，即同步，就是说所有的任务都需要排队，后面的任务需要等前面的任务执行完才能执行，如果前面的任务耗时过长，后面的任务就需要一直等，这是非常影响用户体验的，所以才出现了异步的概念。
​	同步任务：指排队在主线程上依次执行的任务
​	异步任务：不进入主线程，而进入任务队列的任务，又分为宏任务和微任务
​	宏任务： 渲染事件、请求、script、setTimeout、setInterval、Node中的setImmediate 等
​	微任务： Promise.then、MutationObserver(监听DOM)、Node 中的 Process.nextTick等

​	当执行栈中的同步任务执行完后，就会去任务队列中拿一个宏任务放到执行栈中执行，执行完该宏任务中的所有微任务，再到任务队列中拿宏任务，即一个宏任务、所有微任务、渲染、一个宏任务、所有微任务、渲染...(不是所有微任务之后都会执行渲染)，如此形成循环，即事件循环(EventLoop)。
​	nextTick 就是创建一个异步任务，那么它自然要等到同步任务执行完成后才执行。



### 原理分析

​	在执行数据变更的时候，会触发watcher更新，watcher会把自己放到一个队列，然后调用nextTick()，nextTick的参数（一个函数）会被放入事件循环，主线程任务执行完之后就会执行这个任务，对watcher队列排序、遍历、执行watcher对应的run方法，然后render，更新视图。

主要逻辑就是：

- 把传入的回调函数放进回调队列 `callbacks`
- 执行保存的异步任务 `timeFunc`，就会遍历 `callbacks` 执行相应的回调函数了，就可以在render之前拿到最新的信息。



## 15.Computed 和 Watch区别

**第一：先看看computed, watch两个的定义，并说一下使用上的差异？**

​	**计算属性**：

​	定义：要用的属性不存在，要通过已有的属性计算得来(可以从组件数据产生出新的数据)，经常的使用方式是设置一个函数，返回计算之后的结果。

​	原理：底层借助了Object.defineProperty（）方法提供的getter和setter。

​	什么时候执行：初次读取时执行一次，当依赖数据发生变化时再次被调用。

​	优势：与methods实现相比，计算属性有缓存机制（复用），效率更高，调试方便。



​	可能面试官会突然问到computed和methods的区别？

​	computed和methods的差异是它具备缓存性，如果依赖项不变时不会重新计算；其次是调用方式不同，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。



​	**侦听器**：可以检测某个响应式数据的变化并执行副作用，常见用法是传递一个函数，执行副作用，watch没有返回值，但可以执行异步操作等复杂逻辑。（一般用来请求接口）
​	computed一般是纯函数，watch是副作用。

​	监视的属性必须存在，才能进行监视（不会报错，会undefined）。





**第二：在使用场景上的差异，怎么去选择？**

​	computed：常用场景是**简化在`template`模板中的复杂表达式**，模板中出现太多逻辑判断会造成模板不易维护。

​	Watch：常用场景是状态变化之后做一些异步操作。

至于选择哪种方案时，个人觉得有**异步请求，并且逻辑复杂时用Watch，其他情况能用计算属性就首选计算属性。**

computed能完成的功能，watch都可以完成。

watch能完成的功能，computed不一定能完成。





那你说说computed的原理是什么？

**vue 响应式原理**

computed 原理，首先得讲 vue 响应式原理，因为 computed 的实现是基于 `Watcher` 对象的。 那么 vue 的响应式原理是什么呢？众所周知，vue 是基于 `Object.defineProperty` 实现监听的。在 vue 初始化数据 data 和 computed 数据过程中。会涉及到以下几个对象：

- `Observe` 对象（观察者）
- `Dep` 对象（订阅者）
- `Watch` 对象 `Observe` 对象是在 data 执行响应式时候调用，因为 computed 属性基于响应式属性，所以其不需要创建 Observe 对象。 Dep 对象主要功能是做依赖收集，有个属性维护多个 Watch 对象，当更新时候循环调用每个 Watch 执行更新。 Watch 对象主要是用于更新，而且是收集的重点对象



**computed的两种定义方式**

这里谈到 computed 计算属性，首先要知道，其有两种定义方式。

一种是方法，另一种是 `get，set` 属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如 data 的属性、vuex 的属性。

vue 在创建 computed 属性时候，会循环所有计算属性，每一个计算属性会创建一个 watch，并且在通过 `defineProperty` 定义监听，在 get 中，计算属性工作是做依赖收集，在 set 中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为 computed 是懒执行，也就是说第一次初始化之后，便不会执行计算，下一次变更执行重新计算是在 set 中。

**依赖收集的时机**

另一个补充点是依赖收集的时机，computed 收集时机和 data 一样，是在组件挂载前，但是其收集对象是自己属性对应的 watch，而 data 本身所有数据对应一个 watch。





## 16.Vue生命周期

**简述每个周期具体适合哪些场景**

beforecreate : 可以在这加个loading事件，在加载实例时触发。
created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用。
mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数。
beforeDestroy : 可以做一个确认停止事件的确认框。



**vue2：**

**创建阶段：**

beforeCreate(创建前)

​	不能访问this、data、操作DOM节点

Created（创建后）

​	可以访问this、data，不能操作DOM节点，还是虚拟DOM

**挂载阶段：**

brforeMount（挂载前）

​	可以访问this、data，不能操作DOM节点，还是虚拟DOM

​	模板已经编译完成，还没有渲染到页面

Mounted（挂载后）

​	可以访问this、data，虚拟DOM转化为真实DOM，可以操作DOM节点

**更新阶段：**

beforeUpdate（更新前）

Updated（更新后）

**activated、deactivated是用在组件使用keep-alive的时候调用**

| activited   | keep-alive 专属，组件被激活时调用 |
| ----------- | --------------------------------- |
| deactivated | keep-alive 专属，组件被销毁时调用 |

**卸载阶段：**

beforeDestory（销毁前）

Destroyed（销毁后）

​	可以访问this，主要清除定时器，事件监听器





**父子组件生命周期执行顺序：**

1. 加载渲染过程

父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

2. 子组件更新过程

父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

3. 销毁过程

父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed





**vue3**

vue3选项式API生命周期钩子：

`beforeCreate`： 在实例初始化之后、进行数据侦听和事件/侦听器的配置之前同步调用

`created`：在实例创建完成后被立即同步调用

`beforeMount`：在挂载开始之前被调用

`mounted`：在实例挂载完成后被调用

`beforeUpdate`：在数据发生改变后，DOM 被更新之前被调用

`updated`：在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用

`beforeUnmount`(在Vue2中是：`beforeDestroy`)：在卸载组件实例之前调用

`unmounted` (在Vue2中是： `destroyed`)：卸载组件实例后调用



vue3组合式API生命周期钩子：

![钩子函数对比.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da02d3253d74437d80cc8c90047190c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

由上可见， setup() 内部(组合式api)调用的生命周期钩子里是没有beforeCreate 和 Create函数的。
官方解释： 因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写。

![1.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca74f183827f46~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)





## 17.Vue路由

### **$router和$route的区别：**

​	$router：是一个全局路由对象，是根实例
​	包含所有路由，路由的跳转方法（this.$router.push()（本质是向history栈中添加一个路由，添加一个history记录））
​	$route：是局部对象，表示当前的组件的路由对象
​	如：$route.path（字符串，当前路由对象的路径），$route.params（对象，包含路由中的动态片段和全匹配片段的键值对）



### **路由守卫：**

分为：全局的，单个路由独享的，组件级的。

**全局守卫：**

使用方法：

```js
    // main.js 入口文件
    import router from './router'; // 引入路由
    router.beforeEach((to, from, next) => { 
      next();
    });
    router.beforeResolve((to, from, next) => {
      next();
    });
    router.afterEach((to, from) => {
      console.log('afterEach 全局后置钩子');
    });
```

​	vue-router全局有三个守卫：

1. router.beforeEach，全局前置守卫，进入路由之前。
1. router.beforeResolve，全局解析守卫，和beforeEach类似，在每次导航时都会触发，**在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用**。

​	`router.beforeResolve` 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。

3. router.afterEach，全局后置钩子，进入路由之后。



to,from,next这三个参数

to和from是将要进入和将要离开的路有对象，路有对象指的是平时通过this.$route获取到的路由实例。

next:Function 这个参数是个函数，且必须调用，否则不能进入路由(页面空白)。

1. next() 进入该路由。

2. next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。

3. next 跳转新路由，当前的导航被中断，重新开始一个新的导航。

```
 我们可以这样跳转：next('path地址')或者next({path:''})或者next({name:''})
  且允许设置诸如 replace: true、name: 'home' 之类的选项
  以及你用在router-link或router.push的对象选项。
```



**路由独享守卫：**

使用方法：

```js
const routes = [
  {
    path: '/users/:id',
    component: UserDetails,
    beforeEnter: (to, from) => {
      // reject the navigation
      return false
    },
  },
]
```

beforeEnter 守卫 **只在进入路由时触发**，不会在 params、query 或 hash 改变时触发。例如，从 /users/2 进入到 /users/3 或者从 /users/2#info 进入到 /users/2#projects。它们只有在 **从一个不同的 路由导航时**，才会被触发。

你也可以将一个函数数组传递给 beforeEnter，这在为不同的路由重用守卫时很有用。



**组件内的守卫：**

可用的配置API：

你可以为路由组件添加以下配置：

- `beforeRouteEnter` 进入路由前,不能获取this，组件实例未创建。
- `beforeRouteUpdate` 在当前路由改变，但是该组件被复用时调用。
- `beforeRouteLeave` 离开当前路由时

```js
const UserDetails = {
  template: `...`,
  beforeRouteEnter(to, from) {
    // 在渲染该组件的对应路由被验证前调用
    // 不能获取组件实例 `this` ！
    // 因为当守卫执行时，组件实例还没被创建！
  },
  beforeRouteUpdate(to, from) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
  },
  beforeRouteLeave(to, from) {
    // 在导航离开渲染该组件的对应路由时调用
    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
  },
}
```



**完整的导航解析流程：**

1. 导航被触发。
2. 在失活的组件里调用 `beforeRouteLeave` 守卫。
3. 调用全局的 `beforeEach` 守卫。
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫(2.2+)。
5. 在路由配置里调用 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用 `beforeRouteEnter`。
8. 调用全局的 `beforeResolve` 守卫(2.5+)。
9. 导航被确认。
10. 调用全局的 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。









## 18.vue组件缓存

keep-alive

作用：多个组件间动态切换时缓存被移除的组件实例。

生命周期钩子函数：activated（调用时机为首次挂载或每次从缓存中重新拿出）、deactived（从dom上移除、进入缓存以及卸载时调用）。

参数：

	1. include：只有组件name名称匹配的组件才会缓存。
	1. exclude：只有组件name名称不匹配的组件才会缓存。

```vue
<!-- 以英文逗号分隔的字符串 -->
<KeepAlive include="a,b">
  <component :is="view" />
</KeepAlive>

<!-- 正则表达式 (需使用 `v-bind`) -->
<KeepAlive :include="/a|b/">
  <component :is="view" />
</KeepAlive>

<!-- 数组 (需使用 `v-bind`) -->
<KeepAlive :include="['a', 'b']">
  <component :is="view" />
</KeepAlive>
```

3. max：最大缓存实例数。缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。



**在项目中使用：**

1.更改APP.vue

```vue
<div id="app" class='wrapper'>
  <keep-alive>
  <!-- 需要缓存的视图组件 -->
    <router-view v-if="$route.meta.keepAlive">
    </router-view>
  </keep-alive>

  <!-- 不需要缓存的视图组件 -->
  <router-view v-if="!$route.meta.keepAlive">
  </router-view>
</div>
```



2.路由中设置keepAlive

```js
{
  path: 'list',
  name: 'itemList', // 商品管理
  component (resolve) {
    require(['@/pages/item/list'], resolve)
  },
  meta: {
    keepAlive: true,
    title: '商品管理'
  }
}
```



**记录页面滚动位置**

`keep-alive`并不会记录页面的滚动位置，所以我们在跳转时需要记录当前的滚动位置，在触发`activated`钩子时重新定位到原有位置。 具体设计思路：

1. 在`deactivated`钩子中记录当前滚动位置，在这里我使用的是`localStorage`：

```js
 deactivated () {
   window.localStorage.setItem(this.key, JSON.stringify({
    listScrollTop: this.scrollTop
  }))
 }
```

1. 在`activated`钩子中滚动：

```js
this.cacheData = window.localStorage.getItem(this.key) ? JSON.parse(window.localStorage.getItem(this.key)) : null
$('.sidebar-item').scrollTop(this.cacheData.listScrollTop)
```



## 19.Vue this.$set()作用

作用：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。

this.$set(target，prototypeName/index，value)

​	target：要更新的数据源。

​	prototypeName/index：要更改的具体数据（索引）。

​	Value：重新赋的值。





## 20.谈谈你对 keep-alive 的了解？

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：

- 一般结合路由和动态组件一起使用，用于缓存组件；
- 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
- 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。





## 21.父组件可以监听到子组件的生命周期吗？

比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：

```typescript
// Parent.vue
<Child @mounted="doSomething"/>
    
// Child.vue
mounted() {
  this.$emit("mounted");
}

```

以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：

```typescript
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...     

```

当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。



## 22.在哪个生命周期内调用异步请求？

可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面 loading 时间；

- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

  

最终结论来了，我们到底该在什么情况下选择`created`,而又在什么情况下选择`mounted`?

1. 对于作为子组件被调用的组件里，异步请求应当在`mounted`里调用，因为这个时候子组件可能需要涉及到对dom的操作；
2. 对于页面级组件，当我们需要使用`ssr`（服务端渲染）的时候，只有`created`是可用的，所以这个时候请求数据只能用它；
3. 对于页面级组件， 当我们做异步操作时，涉及到要访问dom的操作，我们仍旧只能使用`mounted`;
4. 对于一般情况，`created`和`mounted`都是可以的；

补充一点，在`mounted`被调用时，`vue`不保证子组件也都被挂载完毕了，所以如果希望整个视图渲染完毕再执行操作，需要使用`$nexttick`。

```javascript
mounted: function () {
  this.$nextTick(function () {
    // Code... 
  })
}

```

$nexttick`本身会接收一个回调函数，它实际上会让里面的代码延时执行，类似于setTimeout。

​	我们知道大多数情况下，使用`created`和`mounted`做异步请求没什么区别，但是对于上面提到的几种情况需要选择其中之一。我的个人习惯是：对于页面级组件，一般在`created`里调用，这样做是为了与子组件里需要在`mounted`里调用做一个区分，便于提醒这个知识点。



## 23.使用过 Vue SSR 吗？说说 SSR？

> Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。
>
> 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。

**服务端渲染 SSR 的优缺点如下：**

**（1）服务端渲染的优点：**

- 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；
- 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

**（2) 服务端渲染的缺点：**

- 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；
- 更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。





## 24.vue-router路由模式

​	对于 Vue 这类渐进式前端开发框架，为了构建 **SPA（单页面应用）**，需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— **改变视图的同时不会向后端发出请求**。

​	vue-router 在初始化的时候，会根据 `mode` 来判断使用不同的路由模式，从而 new 出了不同的对象实例。例如 history 模式就用 `HTML5History`，hash 模式就用 `HashHistory`。



为了达到这一目的，浏览器当前提供了以下两种支持：

1. **hash** —— 即地址栏 URL 中的 `#` 符号（此 hash 不是密码学里的散列运算）。
   比如这个 URL：`http://www.abc.com/#/hello`，hash 的值为 `#/hello`。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。**原理是onhashchage事件，可以在window对象上监听这个事件。**

2. **history** —— 利用了 HTML5 History Interface 中新增的 `pushState()` 和 `replaceState()` 方法。（需要特定浏览器支持）
   这两个方法应用于浏览器的历史记录栈，在当前已有的 `back`、`forward`、`go` 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。

   需要后台配置支持。如果刷新时，服务器没有响应响应的资源，会刷出404，

因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。



**使用场景**

一般场景下，hash 和 history 都可以，除非你更在意颜值，`#` 符号夹杂在 URL 里看起来确实有些不太美丽。

history 模式，这种模式充分利用 history.pushState API 来完成。

另外，调用 `history.pushState()` 相比于直接修改 `hash`，存在以下优势：

- `pushState()` 设置的**新 URL 可以是与当前 URL 同源的任意 URL**；**而 `hash` 只可修改 `#` 后面的部分**，因此只能设置与当前 URL 同文档的 URL；
- `pushState()` **设置的新 URL 可以与当前 URL 一模一样**，这样也会把记录添加到栈中；而 `hash` 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
- `pushState()` 通过 `stateObject` 参数可以添加任意类型的数据到记录中；而 `hash` 只可添加短字符串；
- `pushState()` 可额外设置 `title` 属性供后续使用。

当然啦，`history` 也不是样样都好。SPA 虽然在浏览器里游刃有余，但真要通过 URL 向后端发起 HTTP 请求时，两者的差异就来了。尤其在用户手动输入 URL 后回车，或者刷新（重启）浏览器的时候。

1. `hash` 模式下，仅 `hash` 符号之前的内容会被包含在请求中，如 `http://www.abc.com`，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。
2. `history` 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 `http://www.abc.com/book/id`。如果后端缺少对 `/book/id` 的路由处理，将返回 404 错误。[Vue-Router 官网](https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fessentials%2Fhistory-mode.html)里如此描述：**“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”**

**小结**

结合自身例子，对于一般的 **Vue + Vue-Router + Webpack + XXX** 形式的 Web 开发场景，用 `history` 模式即可，只需在后端（Apache 或 Nginx）进行简单的路由配置，同时搭配前端路由的 404 页面支持。



**实现原理**

**（1）hash 模式的实现原理**

早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：

```bash
https://www.word.com#search
```

hash  路由模式的实现主要是基于下面几个特性：

- URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
- hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
- 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
- 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

**（2）history 模式的实现原理**

HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：

```javascript
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
```

history 路由模式的实现主要基于存在下面几个特性：

- pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
- 我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；
- history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。







## 25.vue中的Diff算法

**是什么：**

是一种通过同层的树节点进行比较的高效算法。diff在很多场景下都有应用，在vue中，作用于虚拟dom渲染成真实dom的新旧VNode节点比较。

**diff算法在什么时候运行：**

当我们当前组件所依赖的数值更新和组件创建时运行updata函数，updata函数就会调用组建的render函数，render生成新的虚拟dom树，updata到新虚拟dom树的根节点，然后进入updata函数内部，将_vnode也就是旧虚拟dom树替换成新的虚拟dom树，然后用一个变量将旧虚拟dom树保存起来，接下来调用patch函数进行diff比对。

**特点：**

​	比较只会在同层级比较，不会跨层级比较。

​    在diff比较过程中，循环从两边向中间比较。



## 26.vue中的 ref 是什么？

ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。



## 27.vue.js的两个核心是什么？

数据驱动、组件系统。







# 三、JS

## 1.Window.onLoad 和 DOMContentLoaded事件的先后顺序

**为什么要区分？**

​	开发中我们经常需要给一些元素的事件绑定处理函数。但问题是，如果那个元素还没有加载到页面上，但是绑定事件已经执行完了，是没有效果的。这两个事件大致就是用来避免这样一种情况，将绑定的函数放在这两个事件的[回调](https://link.juejin.cn?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3D%E5%9B%9E%E8%B0%83%26spm%3D1001.2101.3001.7020)中，**保证能在页面的某些元素加载完毕之后再绑定事件的函数。**

​	当然DOMContentLoaded机制更加合理，因为我们可以容忍图片，flash延迟加载，却不可以容忍看见内容后页面不可交互。

​	DOM完整的解析过程：

```
1.解析HTML结构。
2.加载外部脚本和样式表文件。
3.解析并执行脚本代码。/js之类的
4.DOM树构建完成。/DOMContentLoaded
5.加载图片等外部文件。
6.页面加载完毕。/load
	在第4步的时候D0MContentLoaded事件会被触发。
	在第6步的时候load事件会被触发。
```





## 2.深浅拷贝

​	浅拷贝和深拷贝都是对于JS中的**引用类型**而言的，浅拷贝就只是复制对象的引用，如果拷贝后的对象发生变化，原对象也会发生变化。只有深拷贝才是真正地对对象的拷贝。 



**浅拷贝**

浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。

对于目标对象第一层为基本数据类型的数据，就是直接赋值，即「传值」；

而对于目标对象第一层为引用数据类型的数据，就是直接赋存于栈内存中的堆内存地址，即「传址」。

方法一：es6的扩展运算符，方法二：es5的for in。



**深拷贝**

深拷贝不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性，它会在内存的堆区域重新开辟空间。

```js
/**
 * @方法一 : JSON转换。 
 * @缺点1 :JSON不能克隆方法。
 */
export function deepClone1(data) {
	return JSON.parse(JSON.stringify(data));
};

/**
 * @方法二 : 递归深拷贝基础版。 
 * @解决问题1 : 函数属性丢失。
 */
export function deepClone2(data) {
	// 判断数据类型。
	if (typeof data === 'object' && data !== null) {
		// 创建返回值。
		const result = Array.isArray(data) ? [] : {};
		// 遍历。
		for (const key in data) {
			if (data.hasOwnProperty(key)) {
				result[key] = deepClone2(data[key]);
			};
		};
		return result;
	} else {
		return data;
	};
};

/**
 * @方法三 : 递归深拷贝优化版。
 * @解决问题 :优化遍历性能。
 */
export function deepClone3(data) {
	if (typeof data === 'object' && data !== null) {
		// 判断目标数据类型。
		let flag = Array.isArray(data);
		// 返回值。
		const result = flag ? [] : {};
		// 目标数据为数组。
		if (flag) {
			data.forEach((item, index) => {
				result[index] = deepClone3(item);
			});
		} else {
			// 目标数据为 object ，获取键名遍历。
			Object.keys(data).forEach((item) => {
				result[item] = deepClone3(data[item]);
			});
		};
		return result;
	} else {
		return data;
	};
};
```



## 3.var let const 区别

​	var： 关键字声明的变量，存在变量提升，会提升到该作用域的最顶端，因为javaScript引擎，在代码预编译时，会自动将所有代码里面的`var`关键字声明的语句提升到当前作用域的顶端。

​	let：关键字声明的变量，有块级作用域，所有外面的语句块访问不到，没有变量提升，在相同作用域内禁止重复声明，不然会报错。

​	const： 关键字声明的是常量，一旦定义就不能修改的值，这个指的是不能修改指针，但能修改值，还需注意必须初始化，不然报错，其他的点和let基本相同，块级作用域、没有变量提升、相同作用域中禁止重复声明。都有暂时性死区。



var let const最大的区别：

var在全局作用域声明的变量会挂载到window对象上，可能会覆盖window对象上的某个属性，而let const 声明的变量则不会有这一行为。



**块级声明：只在当前函数下声明的变量有效，在代码块和{}括号之间有效。if是不会构成块级作用域，if语句var会提升到外部。**

**暂时性死区：只有等到声明变量的那一行代码出现，才可以获取和使用该变量，意义在于为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。**



**总结：**

**`var`和`let`/`const`的区别**

1. 块级作用域
2. 不存在变量提升
3. 暂时性死区
4. 不可重复声明
5. let、const声明的全局变量不会挂在顶层对象下面

**`const`命令两个注意点:**

1. const 声明之后必须马上赋值，否则会报错
2. const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。



## 4.WebSocket和socket

socket是传输控制层协议，websocket是应用层协议，都是双向通信协议。

**websocket连接过程：**

1. 浏览器、服务器建立TCP连接，三次握手，这是通信的基础，传输控制层，失败后续不执行。

2. TCP连接成功后，浏览器通过HTTP协议向服务器传送websocket支持的版本号等信息（开始前的http握手）。

3. 服务器受到客户端的握手请求后，同样采用http协议回馈数据。

4. 但收到了连接成功的消息后，通过TCP通道进行传输通信。

   

**html5与websocket的关系：**

​	都是基于TCP的，都是可靠性传输协议，都是应用层协议。

​	websocket API是html5标准的一部分，但并不代表它一定要用在html中，或者只能在基于浏览器的应用程序中使用，实际上，许多语言、框架和服务器都提供了websocket支持，例：nodejs的socket.io、c++的websocket++等...

​	不同点：

​		websocket是双向通信协议，模拟socket协议，http是单向的。

​		websocket是需要浏览器和服务器握手进行建立连接的。而http是浏览器发起向服务器的链接，服务器预先并不知道这个链接。

​		websocket在建立握手时，数据是通过http传输的，但建立之后，真正传输就不需要http协议了。



**网络基层模型：**

![image-20230103100327582](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230103100327582.png)





## 5.防抖节流

**防抖：**

```js
/**
 * @title :函数防抖(debounce)。
 * @effect :限制事件的触发频率，避免界面卡顿或减少对服务器的请求。
 * @introduce : 防抖是指在一定时间内再次触发此事件 ，会清空上次事件重新开始，在规定时间内没有再次触发，那么这个事件才会执行。
 * @scene :按钮提交场景（防止多次提交，只提交最后一次）、搜索框。
 * @params :callback执行函数, wait执行周期。
 * @sampleCode :debounce((e) => { fn(item) },1000);
 * @思路 :定义定时器，判断定时器存在则清除定时器，并重新启动定时器执行回调。
 */

export function debounce(callback, wait) {
	// 定时器变量。
	let timeId = undefined;
	// 返回函数。
	return function (...args) {
		// 判断当定时器存在时清除定时器。
		if (timeId !== undefined) {
			clearTimeout(timeId);
		};
		// 启动定时器。
		timeId = setTimeout(() => {
			// 执行回调。
			callback(...args);
			// 充值定时器变量。
			timeId = undefined;
		}, wait);
	};
};
```



**节流：**

```js
/**
 * @title :函数节流(throttle)。
 * @effect :限制事件的触发频率，避免界面卡顿或减少对服务器的请求。
 * @introduce :在 wait 毫秒内最多执行 callback 一次，只有超过 wait 毫秒后才会执行第二次。
 * @scene :窗口调整、页面滚动、DOM元素拖拽、疯狂点击事件。
 * @params :callback执行函数, wait执行周期。
 * @sampleCode :throttle((e) => { fn(item) },1000);
 * @思路 :定义开始时间为0，判断当执行事件减去开始时间大于规定时间时，执行事件，并更改开始时间。
 */
export function throttle(callback, wait) {
	// 定义开始时间。
	let start = 0;
	// 返回结果为函数。
	return function (...args) {
		// 获取当前时间戳。
		let now = Date.now();
		// 判断。
		if (now - start >= wait) {
			// 符合条件，执行该函数。
			callback(...args);
			// 修改开始时间。
			start = now;
		};
	};
};
```



## 6.js数据类型

**基本数据类型：**

​	string、number、undefined、null、boolean、symbol。

​	基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。

**引用数据类型：**

​	object、array、function。

​	引用数据类型是保存在堆内存中的对象，不能直接访问，只能访问其在栈内存中的引用地址。

**区别：**

1. 声明变量时的不同内存分配：

   原始值（基本数据类型）的大小固定，可将它们存储较小的内存区域，便于快速查询变量的值。

   引用值：存储在变量处的是一个指针，指向存储对象的内存地址。因为引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查询的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。

2. 不同的访问机制。

3. 复制变量时的不同：

   ​	原始值：两个变量完全独立，只是有相同的value而已。

   ​	引用值：会把内存地址赋值给新变量，两个变量的值指向内存中的同一对象，任何一方改变都会反映到另一个。



**类型判断的方法：**

**1. typeof 检测基础数据类型和函数**

​	它能准确判断出的数据类型有：Number，String，Boolean，Undefined，Symbol，BigInt，Function。

​	它的缺点就是不能准确判断 null 的类型，而是返回 “object”。对于数组，日期，普通对象等数据，统一返回 “object”。

​	所以在判断基本数据类型（除了 null）和函数类型时，都会使用它。



**2. constructor 返回实例对象的构造函数**

​	本意是用来标识自己的构造函数，却用来判断数据类型，当然也存在一定风险，基本不用。

1. null、undefined没有构造函数，自然也就访问不到该属性，会报错。

2. constructor可以被改写，所以不一定准确。

例子:

```js
console.log((1).constructor === Number) // true

console.log([1, 2, 3].constructor === Array) // true

console.log(undefined.constructor === Array) // 报错
```



**3. instanceof 沿着原型链去找**

它的作用是检测实例对象是不是属于某个构造函数，可以用来做数据类型的检测。

它也有缺点：

1. 不能检测基本数据类型。

2. 原型链可能被修改，导致检测结果不准确。
3. 只要能在原型链上找到构造函数，就返回true，所以类型可能不准确。

```js
console.log(1 instanceof Number) // false

console.log([] instanceof Array) // true

console.log([] instanceof Object) // true
```



**4. toString.call（）**

​	专门用来检测数据类型的方法，返回的值是一个`[object string]`字符串，例：

```js
console.log(toString.call('123'))        // [object String]
console.log(toString.call(null))         // [object Null]
console.log(toString.call(true))         // [object Boolean]
console.log(toString.call({}))           // [object Object]
console.log(toString.call([]))           // [object Array]
console.log(toString.call(function(){})) // [object Function]
console.log(toString.call(new Map))      // [object Map]
console.log(toString.call(new WeakSet))  // [object WeakSet]

```

​	通常会编写一个函数，对返回的字符串从第8位做一个截取，截取到倒数第一位，再去做类型比较。



**5. Array.isArray：专业检测数组**

`Array.isArray([]) // true`



**6. Number.isNaN 判断一个数字是不是NaN**

NaN 用于表示不是一个数字，它不等于任何值，包括它本身。在 ES6 之前，windows 对象提供了一个全局方法 `isNaN`，用于判断一个数字是不是 NaN：

```js
isNaN(10) // false
isNaN('abc') // true
isNaN(NaN) // true
```

可以发现，isNaN 对于字符串的检测结果也是 NaN。但这其实并不严谨，它对要判断的数据做了一个隐式类型转换，先转为数字再进行判断。而NaN 的检测应该仅限于数字类型，所以 ES6 提供了 Number.isNaN 方法：

```js
Number.isNaN(NaN) // true
Number.isNaN('123') // false
```

它能判断一个值是否严格等于NaN。



**7. 等比较**

双等或者全等



## 7.js栈堆存储

​	`JavaScript`具有自动垃圾回收机制，周期性会检查没有使用的变量，进行回收释放。所以在闭包中，如果引用了外部的变量，则无法进行释放和回收，一般会传参进去。

​	在`JS`中，每一个数据都需要一个内存空间，内存空间又分为栈内存与堆内存。

**栈内存一般储存基础数据类型，栈内存数据遵循先进后出**。

**堆内存一般储存引用数据类型，引用类型在栈中保存指针，在堆中保存对象值**。





## 8.箭头函数和普通函数区别

1. 声明方式不同，普通函数需要关键字function，箭头函数只要箭头即可，更简洁。
2. 箭头函数不能作为构造函数，普通函数可以。箭头函数是匿名函数，不能使用new。

2. 箭头函数没有原型，普通函数有。

3. 箭头函数不能绑定arguments，用剩余参数...解决，普通函数绑定了参数列表对象。

4. this指向问题：

   箭头函数没有this，this为上层函数作用域的this对象，如没有则指向顶部window。

   普通函数的this指向该函数的调用者。

   call、apply、bind会改变普通函数的this指向，但不会改变箭头函数。

5. 箭头函数内不能用yieId且不能用作Generator函数，而普通函数可以。



## 9.Promise

**定义：**

​	Promise 是一门新的技术(ES6 规范)，是为了解决异步而存在的一个方案。
​	从语法上来说：Promise是一个构造函数。
​	从功能上来说：Promise用来封装一个异步操作并可以获取其成功/失败的结果。



**为什么使用promise：**

1. 指定回调函数方式更灵活，

   1.1 旧的: 必须在启动异步任务前指定。

   1.2 promise: 启动异步任务 => 返回promie对象 => 给promise对象绑定回调函数(甚至可以在异步任务结束后指定/多个) 。

2. 对象的状态不受外界影响，状态是不可逆的。

3. 支持链式调用，可以解决回调地狱（解决方案：promise链式调用，终极解决方案：async/await）问题。



**简述 promiseA+规范**

promise只是一种规范，es6中的promise遵循promiseA+规范。

1. promise是管理异步的方案。
2. promise有3种状态，默认是pedding状态，当调用resolve的时候会把状态变成功状态，当调用reject的时候会把状态变失败状态，状态一旦凝固不可逆转（只能从pedding转向成功或失败)。
3. promise原型上的then方法和catch方法，当状态是成功的时候，自动调用then方法，并且可以从then中获取到成功的数据，当状态是失败的时候，自动调用catch方法，并且可以从catch中捕获到错误信息。



**promise方法：**

1. Promise.then()
2. Promise.catch() (发生错误时触发回调函数)
3. Promise.finall()（不管最后状态如何，都会执行操作）
4. Promise.all()（全部成功结束，一起返回）
5. Promise.allSettled()（不管是成功还是失败，全部结束，一起返回）
6. Promise.any()（谁先成功，谁先返回）
7. Promise.race()（不管成功或失败，谁先结束就返回谁）
8. .all()和.allSettled()的区别
   （1）all()：如果有一个Promise对象报错，all()无法执行直接报错，allSettled()：不管有没有报错，都会把Promise实例的数据返回
   （2）all()返回一个直接包裹resolve内容的数组，allSettled()返回一个包裹着对象的数组。





**promise 的几个关键问题**

**1.如何改变 promise 的状态?**

​	(1) resolve(value): 如果当前是 pending 就会变为 resolved。

​	(2) reject(reason): 如果当前是 pending 就会变为 rejected。

​	(3) 抛出异常: 如果当前是 pending 就会变为 rejected。

**2.一个 promise 指定多个成功/失败回调函数, 都会调用吗?** 

​	当 promise 改变为对应状态时都会调用。

**3.改变 promise 状态和指定回调函数谁先谁后?**

​	(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调。

​	(2) 如何先改状态再指定回调? 

​			① 在执行器中直接调用 resolve()/reject()。

​			② 延迟更长时间才调用 then()。

​	(3) 什么时候才能得到数据? 

​			① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据。

​			② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据。

**4.promise.then()返回的新 promise 的结果状态由什么决定?**

​	(1) 简单表达: 由 then()指定的回调函数执行的结果决定。

​	(2) 详细表达: 

​			① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常。

​			② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值。

​			③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果。

**5.promise 如何串连多个操作任务?**

​	(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用。

​	(2) 通过 then 的链式调用串连多个同步/异步任务。

**6.promise 异常传透?**

​	(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调。

​	(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理。

**7.中断 promise 链?**

​	(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数。

​	(2) 办法: 在回调函数中返回一个 pendding 状态的 promise 对象。



**实现promise:**

```js
/**
 * @title : 声明构造函数 promise 。
 */
export function MyPromise(callback) {
	// 添加属性。
	this.promiseStatus = 'pending';
	this.promiseResult = null;
	// 声明属性。
	this.callbackSyncs = [];
	// 存储实例this的值。
	const self = this;

	// resolve 函数。
	function resolve(data) {
		// 判断状态，只能修改一次。
		if (self.promiseStatus !== 'pending') return;
		// 1. 改变状态（promiseStatus）。
		self.promiseStatus = 'fulfilled';
		// 2. 设置结果值（promiseResult）。
		self.promiseResult = data;
		// 调用成功的回调函数。
		setTimeout(() => {
			self.callbackSyncs.forEach(item => {
				item.onResolved(data);
			});
		});
	};

	// reject 函数。
	function reject(data) {
		// 判断状态，只能修改一次。
		if (self.promiseStatus !== 'pending') return;
		// 1. 改变状态（promiseStatus）。
		self.promiseStatus = 'rejected';
		// 2. 设置结果值（promiseResult）。
		self.promiseResult = data;
		// 调用失败的回调函数。
		setTimeout(() => {
			self.callbackSyncs.forEach(item => {
				item.onRejected(data);
			});
		});
	};

	try {
		// 同步执行[执行器函数]。
		callback(resolve, reject);
	} catch (e) {
		// 更改promise状态为失败。
		reject(e);
	};
};

// 添加then方法。
MyPromise.prototype.then = function (onResolved, onRejected) {
	const self = this;
	// 判断回调函数参数。
	if (typeof onRejected !== 'function') {
		onRejected = reason => {
			throw reason;
		};
	};
	if (typeof onResolved !== 'function') {
		onResolved = value => value;
	};
	return new MyPromise((resolve, reject) => {
		// 封装函数。
		function callback(type) {
			try {
				// 获取回调函数执行结果。
				let result = type(self.promiseResult);
				// 判断。
				if (result instanceof Promise) {
					// 是 promise 类型。
					result.then(value => {
						resolve(value);
					}, reason => {
						reject(reason);
					});
				} else {
					resolve(result);
				};
			} catch (e) {
				reject(e);
			};
		};
		// 调用回调函数。
		if (this.promiseStatus === 'fulfilled') {
			setTimeout(() => {
				callback(onResolved);
			});

		};
		if (this.promiseStatus === 'rejected') {
			setTimeout(() => {
				callback(onRejected);
			});
		};
		// 判断 pending 状态。
		if (this.promiseStatus === 'pending') {
			// 保存回调函数。
			this.callbackSyncs.push({
				onResolved: function () {
					callback(onResolved);
				},
				onRejected: function () {
					callback(onRejected);
				}
			});
		};
	});
};

// 添加catch方法。
MyPromise.prototype.catch = function (onRejected) {
	return this.then(undefined, onRejected);
};

// 添加 resolve 方法。
MyPromise.resolve = function (data) {
	return new MyPromise((resolve, reject) => {
		if (data instanceof Promise) {
			value.then(value => {
				resolve(value);
			}, reason => {
				reject(reason);
			});
		} else {
			// 状态设置为成功。
			resolve(data);
		};
	});
};

// 添加 reject 方法。
MyPromise.reject = function (data) {
	return new MyPromise((resolve, reject) => {
		reject(data);
	});
};

// 添加 all 方法。
MyPromise.all = function (promises) {
	return new MyPromise((resolve, reject) => {
		let count = 0;
		let data = [];
		// 遍历。
		for (let i = 0; i < promises.length; i++) {
			promises[i].then(value => {
				count++;
				data[i] = value;
				if (count === promises.length) {
					resolve(data);
				};
			}, reason => {
				reject(reason);
			});
		};
	});
};

// 添加 race 方法。
MyPromise.race = function (promises) {
	return new MyPromise((resolve, reject) => {
		for (let i = 0; i < promises.length; i++) {
			promises[i].then(value => {
				resolve(value);
			}, reason => {
				reject(reason);
			});
		};
	});
};
```



## 10.this的理解

​	this是一个对象，表示当前代码的执行环境。

​	this的值由它的所处环境决定的，不同场景this指向不同。

​	this的值可以改变，使用call，apply，bind。

**this指向问题：**

1. **全局执行环境（默认绑定）：**全局上下文默认this指向window，严格模式下undefined。

2. **纯粹的函数调用（默认绑定）：**代表全局对象，严格模式undefined。

3. **作为对象方法的调用（隐式绑定）：**this指向它的调用者。

4. **作为构造函数调用（new，优先级最高）：**

   ​	所谓构造函数，就是通过这个函数，可以生成一个新对象。这时**this，指向这个新对象（实例对象）**。

​			new() 的过程大概可以表示为：

​		（1）调用构造函数，在堆内为这个创建一个空对象，并使用this指向这个空对象。

​		（2）然后执行构造函数语句，最后返回this。

5. **apply、bind、call调用（显示绑定）：**可以改变this指向，如果不填指向谁，默认全局window，bind是返回一函数。

6. **箭头函数：**无this，它的this是上下文中定义的this，也就是说它的this来自于函数作用域链。箭头函数的this指向外层第一个普通函数的this，无法更改。
7. **事件绑定中的this：**this指向事件源，也就是谁绑定了这个事件。
8. **定时器中的this：**指向window，因为定时器中采用回调函数作为处理函数，而回调函数的this => window。



**绑定优先级：**

new > 显示绑定 > 隐式绑定 > 默认绑定。



## 11.0.1+0.2!==0.3

原因：

​	在0.1+0.2的计算过程中发生了两次精度丢失，第一次在0.1和0.2转成双精度二进制浮点数是，由于二进制浮点数的小数点只能存储52位，导致小数点后53位的数要进行为1则进为0则舍的操作，从而造成一次精度丢失，第二次在0.1和0.2转成二进制浮点数后，二进制浮点数相加的过程中，小数位相加导致小数位多出了一位，又要让第53位进行为1则进0则舍的操作，又造成一次精度丢失。



解决方案：

1. **toFixed() <不推荐>**

```js
0.123.toFixed(2) // 0.12
```

缺点：在不同浏览器得出的值可能不同，不是严格的四舍五入。

2. **乘以一个10的幂次方**

​		把需要计算的数乘以10的n次方，计算完之后再除以10的n次方。

```js
//封装
mathFloat = function (float, digit) {
  const math = Math.pow(10, digit);
  return parseInt(float * math, 10) / math;
}
mathFloat(0.1 + 0.2, 3)  // 0.3
```

3. 可以使用第三方库：Math.js



## 11.JS堆栈内存释放

- 堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。
- 堆内存释放：将引用类型的空间地址变量赋值成 `null`，或没有变量占用堆内存了浏览器就会释放掉这个地址
- 栈内存：提供代码执行的环境和存储基本类型值。
- 栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。

> **但栈内存的释放也有特殊情况：① 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放。② 全局下的栈内存只有页面被关闭的时候才会被释放**





## 12.闭包

**它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。**

闭包是函数嵌套函数，有权访问上一级函数作用域中的变量。

形成闭包的原因：内部的函数存在外部作用域的引用就会导致闭包。

闭包变量存储的位置：存储的位置是堆内存。

- 假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。

特点：

1. 全局变量不被释放。

2. 局部变量无法被外部访问。

优点：

1. 可以让一个变量长期在内存不被释放。

2. 闭包中避免全局变量污染。
3. 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化

缺点：

1. 本应被销毁的变量，因为闭包的原因没有被销毁，长期存在，容易造成内存泄漏。

怎么检查内存泄露

- performance 面板 和 memory 面板可以找到泄露的现象和位置。

闭包可以完成功能：防抖、节流。



## 13.内存泄漏

​	代码中分配一些顽固的内存，浏览器无法进行回收，这些内存还在一直不停地分配就会导致后面所用内存不足，造成泄露。

如何避免闭包引起的内存泄漏

（1）再退出函数前，将不使用的局部变量全部删除。使变量赋值null。

（2）避免变量的循环赋值和引用。

（3）当不需要定时器 interval 或者 timeout 时，最好调用 clearInterval 或者 clearTimeout来清除。

（4）vue、react中在卸载生命周期里注销事件监听器（window.removeEventListener）

（5）清理的Console输出。





## 14.原型和原型链的理解，作用

**原型**：JS声明构造函数时，会在内存中创建一个对应的对象，这个对象就是原函数的原型，构造函数有一个prototype属性，prototype的值指向函数的原型。

**原型的作用**：1.数据共享 节约内存空间  2.实现继承。

 

**原型链**：当在实例化对象中访问一个属性时，首先会在该对象内部（自身属性）寻找，如果找不到，则会向其__proto__指向的原型中寻找，如果还找不到，则继续向原型中__proto__指向的上级原型中寻找，直至找到或Obeject.prototype.__propto__值为null为止，这种链状过程为原型链。

**原型链作用**：查找对象的属性（方法）。

`Object.prototype` 的隐式原型指向 `null`。



## 15.js事件循环机制(event loop)

JS是单线程，浏览器在执行JS代码时先执行同步代码，在执行异步代码

主要分为主线程、微任务、宏任务 

宏任务：由浏览器规定的  setTimeout  setInterval  文件操作 setImmediate  Ajax  I/O  UI rendering

微任务：由ES6越发规定的 Promise.then  Promise.catch  Promise.finally  nextTick MutationObserver  Object.observe

其实，event loop用简单点的话去解释，就是：

> 1、先执行主线程
>
> 2、遇到宏队列（macrotask）放到宏队列（macrotask）
>
> 3、遇到微队列（microtask）放到微队列（microtask）
>
> 4、主线程执行完毕
>
> 5、执行微队列（microtask），微队列（microtask）执行完毕
>
> 6、执行一次宏队列（macrotask）中的一个任务，执行完毕
>
> 7、执行微队列（microtask），执行完毕
>
> 8、依次循环。。。



## 16.for in 和 for of 区别

它们都可以用于遍历，不过for in 遍历的是数组的索引（index），for of 遍历的是数组元素值（value）。

**for in**

for in 更适合遍历对象，也可以遍历数组，但会存在一些问题。

 问题1：index索引为字符串类型，不能进行几何运算。

 问题2：遍历顺序有可能不是实际数组的内部顺序。

for in 会遍历数组所有的可枚举属性，包括原型。当不想遍历原型时，可使用`hasOwnProperty()`方法可以判断某属性是不是该对象的实例属性。



**for of**

for of 只能遍历数组，而且遍历的只是数组内的元素，不包括原型属性和索引。



## 17.跨域以及解决方式

​	同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

![url的组成](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/23/1638b3579d9eeb32~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

​	**当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。不同域之间相互请求资源，就算作“跨域”。

​	**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了**。



**跨域解决方案**

### 1.jsonp

**1) JSONP原理**

**利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**

**2) JSONP和AJAX对比**

JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）

**3) JSONP优缺点**

JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**

**4) JSONP的实现流程**

- 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。
- 创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。
- 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串。
- 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。

例子：

```js
// index.html
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script')
    window[callback] = function(data) {
      resolve(data)
      document.body.removeChild(script)
    }
    params = { ...params, callback } // wd=b&callback=show
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(script)
  })
}
jsonp({
  url: 'http://localhost:3000/say',
  params: { wd: 'Iloveyou' },
  callback: 'show'
}).then(data => {
  console.log(data)
})
```

上面这段代码相当于向`http://localhost:3000/say?wd=Iloveyou&callback=show`这个地址请求数据，然后后台返回`show('我不爱你')`，最后会运行show()这个函数，打印出'我不爱你'

```javascript
// server.js
let express = require('express')
let app = express()
app.get('/say', function(req, res) {
  let { wd, callback } = req.query
  console.log(wd) // Iloveyou
  console.log(callback) // show
  res.end(`${callback}('我不爱你')`)
})
app.listen(3000)
```



###  2.cors

​	**CORS 需要浏览器和后端同时支持，需要配置响应头等配置项。**

​	浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。



### 3.postMessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

**postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递**。

> otherWindow.postMessage(message, targetOrigin, [transfer]);

- message: 将要发送到其他 window的数据。
- targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
- transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

接下来我们看个例子： `http://localhost:3000/a.html`页面向`http://localhost:4000/b.html`传递“我爱你”,然后后者传回"我不爱你"。

```javascript
// a.html
  <iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"></iframe> //等它加载完触发一个事件
  //内嵌在http://localhost:3000/a.html
    <script>
      function load() {
        let frame = document.getElementById('frame')
        frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据
        window.onmessage = function(e) { //接受返回数据
          console.log(e.data) //我不爱你
        }
      }
    </script>
复制代码
// b.html
  window.onmessage = function(e) {
    console.log(e.data) //我爱你
    e.source.postMessage('我不爱你', e.origin)
 }
```





**总结**

1. CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案

2. JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

3. 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。

4. 日常工作中，用得比较多的跨域方案是cors和nginx反向代理



## 18.图片懒加载实现原理以及核心API

**原理分析**

- 先将img标签的src链接设为同一张图片(默认图片)，当js监听到该图片进入可视窗口时，再将实际地址应用。

**实现方法**

- 判断元素是否在可视范围

```js
  /**
   * 判断元素是否在可视范围
   */
  function isVisible(ele){
    let windowHeight = window.innerHeight
    let position = ele.getBoundingClientRect() //方法返回元素的大小及其相对于视口的位置。
    // 当元素的top偏移量小于页面大小并且大于高度的负数
    if(position.top<windowHeight && position.top>-position.height){
      return true
    }
    return false
  }
```

- 对图片实现懒加载

```js
  /**
   * 对图片进行懒加载
   */
  function lazyLoad(img, src){
    if(img && src && isVisible(img)){ // 元素存在，元素未被加载，元素可见
      setTimeout(function(){
        img.setAttribute('src', src)
      }, 1000) // 模拟网络请求
    }
  }
```

- 添加滚动监听

```javascript
  // 窗口滚动
  window.addEventListener('scroll', function(){
    lazyLoad(img, src)
  })
```



## 19.优雅捕获异步错误

1. 使用promise 管理异步的方案，promise实例的then方法获取成功信息，catch捕获错误信息。

2. 使用async 和 await 配合try catch 获取错误；async修饰函数，try中调用await获取异步数据，如果try中的异步有错误，catch中获取到错误。



## 20.ES6

1. 取值：解构赋值

```js
const {a:a1,b,c,d,e} = obj || {};
//ES6的解构赋值虽然好用。但是要注意解构的对象不能为`undefined`、`null`。否则会报错，故要给被解构的对象一个默认值。
```

2. 合并数据，数组去重：ES6扩展运算符

```js
const a = [1,2,3];
const b = [1,5,6];
const c = [...new Set([...a,...b])];//[1,2,3,5,6]

const obj1 = {
  a:1,
}
const obj2 = {
  b:1,
}
const obj = {...obj1,...obj2};//{a:1,b:1}
```

3. 拼接字符串：模板字符串

```js
const name = '小明';
const score = 59;
const result = `${name}${score > 60?'的考试成绩及格':'的考试成绩不及格'}`;
```

4. if判断：ES6中数组实例方法`includes`

```js
if(
    type == 1 ||
    type == 2 ||
    type == 3 ||
    type == 4 ||
){
   //...
}
改进
const condition = [1,2,3,4];

if( condition.includes(type) ){
   //...
}
```

5. 列表搜索：在项目中，一些没分页的列表的搜索功能由前端来实现，搜索一般分为精确搜索和模糊搜索。搜索也要叫过滤，一般用`filter`来实现。

   精确搜索的话不会用ES6中的`find`吗？性能优化懂么，`find`方法中找到符合条件的项，就不会继续遍历数组。

```js
const a = [1,2,3,4,5];
const result = a.find( 
  item =>{
    return item === 3
  }
)
```

6. 扁平化数组：

   一个部门JSON数据中，属性名是部门id，属性值是个部门成员id数组集合，现在要把有部门的成员id都提取到一个数组集合中。

```js
const deps = {
'采购部':[1,2,3],
'人事部':[5,8,12],
'行政部':[5,14,79],
'运输部':[3,64,105],
}
let member = [];
for (let item in deps){
    const value = deps[item];
    if(Array.isArray(value)){
        member = [...member,...value]
    }
}
member = [...new Set(member)]
```

获取对象的全部属性值还要遍历吗？`Object.values`忘记了吗？还有涉及到数组的扁平化处理，为啥不用ES6提供的`flat`方法呢，还好这次的数组的深度最多只到2维，还要是遇到4维、5维深度的数组，是不是得循环嵌套循环来扁平化？

```js
const deps = {
    '采购部':[1,2,3],
    '人事部':[5,8,12],
    '行政部':[5,14,79],
    '运输部':[3,64,105],
}
let member = Object.values(deps).flat(Infinity);
//其中使用Infinity作为flat的参数，使得无需知道被扁平化的数组的维度。
```





# 

# 四、Node

## 1.使用过的koa2中间件

1. koa-router

​	koa.js为了保持自身的精简，并没有像Express.js自带了路由功能，因此koa-router做了很好的补充，作为koa星数最多的中间件，koa-router提供了全面的路由功能，比如类似Express的app,get/post/put的写法，URL命名参数、路由命名、支持加载多个中间件、嵌套路由等

2. koa-bodyparser

​	koa.js并没有内置request Body的解析器，当我们需要解析请求体时需要加载额外的中间件，官方
提供的koa-bodyparser是个很不错的选择，支持x-www-form-urlencoded,application/json等格式
的请求体，但不支持form-data的请求体，需要借助formidable这个库，也可以直接使用koa-body 或 koa-better-body

3. koa-view

   视图模板渲染中间件。

4. koa-static

   用作类似nginx的静态文件服务，在本地开发时特别方便，可用于加载前端文件或后端fake数据。

5. koa-logger

   提供了输出请求日志的功能，包括请求的url、状态码、响应时间、响应体大小等信息，对于调试和跟踪应用程序特别有帮助。



**自定义中间件：**

```js
async function koaMiddleware(ctx, next){
    try{
        // do something
        await next()
        // do something
    }
    .catch(err){
        // handle err
    }    
}

//使用在app.use(koaMiddleware())
```



**介绍pm2**
PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动
重启、负载均衡等，而且使用非常简单

只需一行：pm2 start app.js -i 1，-i表示实例程序的个数，也就是工作线程

**能保持你的程序不中断运行**
如果有任何工作线程意外挂掉了，PM2会立即重启他们，当前你可以在任何时候重启，只需：

![image-20230103134532169](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230103134532169.png)





# 五、小程序

## 1.如何避免微信小程序中app.js中onShow事件的n次触发的问题？

​	在开发中，遇到了一个小难题，就是app.js中onShow事件总是会因调用其它Api而触发，例如：
wx.chooseImage,还有wx.makePhoneCall,wx.previewImage,还有好多都会触发app.js中的onShow事件。
​	小程序热启动确实是个坑，因为通过扫码或分享进入也会热启动，一般开发者都只在onLaunch处理扫码进入相关逻辑，热启动时就出bug了。
​	目前比较好的办法就是onShow中通过首个参数optnios下的scene判断进入的场景，根据场景处理相关逻辑。
​	如果是转发的场景的话，可以把业务代码写在onLoad函数中，因为分享后的事件不会执行onLoad,
只会执行onShow。





## 2.微信小程序的相关文件类型

wxml

wxss

json设置，标题等

app.json

app.js



## 3.封装小程序的数据请求

1. 将所有接口放在统一的js文件中导出
2. 在app.js中创建封装请求数据的方法
3. 在子页面中调用封装的方法请求数据





## 4.参数传值的方法

一、给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或
onload的param参数获取。但data-名称不能有大写字母和不可以存放对象
二、设置id的方法标识来传值通过e.currentTarget.id获取设置的id的值，然后通过设置全局对
象的方式来传递数值
三、在navigator中添加参数传值



## 5.提高小程序应用速度

1. 组件化方案。

2. 减少默认data的大小。



## 6.简述微信小程序原理

答：微信小程序采用]avaScript、WXML、WXSS三种技术进行开发，从技术讲和现有的前端开发差
不多，但深入挖掘的话却又有所不同。

​	**JavaScript**：首先JavaScript的代码是运行在微信App中的，并不是运行在浏览器中，因此一些H5技术的应用，需要微信App提供对应的API支持，而这限制住了H5技术的应用，且其不能称为严格的H5,可以称其为伪H5,同理，微信提供的独有的某些API,H5也不支持或支持特的不是特别好。

​	**WXML**：WXML微信自己基于XML语法开发的，因此开发时，只能使用微信提供的现有标签，HTML的标签是无法使用的。

​	**WXSS**：WXSS具有CSS的大部分特性，但并不是所有的都支持，而且支持哪些，不支持哪些并没有详细的文档。

​	微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现。
​	小程序分为两个部分webview和appService。其中webview主要用来展现UI,appService有来处理业务逻辑、数据及接口调用。
​	它们在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理。



## 7.分析下微信小程序的优劣势？

优势：

1. 无需下载，通过搜索和扫一扫就可以打开。
2. 良好的用户体验：打开速度快。
3. 开发成本要比App要低。
4. 安卓上可以添加到桌面，与原生App差不多。
5. 为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程，不能通过审查的小程序是无法发布到线上的。

劣势：

1. 限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。
2. 样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。
3. 推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。
4. 依托于微信，无法开发后台管理功能。



## 8.微信小程序与H5的区别

**第一条是运行环境的不同**
	传统的HTML5的运行环境是浏览器，包括webview,而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。

**第二条是开发成本的不同**
	只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG。

**第三条是获取系统级权限的不同**
	系统级权限都可以和微信小程序无缝衔接。

**第四条便是应用在生产环境的运行流畅度**
	长久以来，当HTM5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立。





## 9.小程序的双向绑定和Vue区别

小程序直接this.data的属性是不可以同步到视图的，必须调用this.setData({})。4



## 10.实现下拉刷新

首先在全局 config 中的 window 配置 enablePullDownRefresh。
在Page中定义onPullDownRefresh钩子函数，到达下拉刷新条件后，该钩子函数执行，发起请求方法请求返回后，调用wx.stopPullDownRefresh停止下拉刷新。



## 11.bindtap 和 catch 的区别

相同点：
首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分。
不同点：
他们的不同点主要是bindtap:是不会阻止冒泡事件的，catchtap:是阻止冒泡的。



## 12.微信小程序页面跳转

1. wx.navigateTo()

​	保留当前页面，跳转到应用内的某个页面，但不能跳到tabbar页面。

2. wx.redirectTo()

​	关闭当前页面，跳转到应用内的某个页面，但不能跳到tabbar页面。

3. wx.switchTab()

​	跳转到 abBar 页面，并关闭其他所有非tabBar页面。

4. wx.navigateBack()

​	关闭当前页面，但会上一页或多级页面。可通过getCurrentPages()获取当前的页面栈，决定需要返回几层。

5. wx.reLaunch()

​	关闭所有页面，打开到应用内的某个页面。





# 六、CSS

## 1.盒模型

盒模型 = content内容、padding内边距、border边框、margin外边距组成。

**标准盒模型（W3C标准盒模型）：**

​	属性width只包含内容content，不包含border和padding、margin

​	元素宽度=width+padding+border+margin

​	box-sizing:content-box

​	添加padding、border元素会向外扩张

**怪异盒模型（IE盒模型）：**

​	属性width包含content内容、padding和border

​	元素宽度=width+margin

​	box-sizing:border-box

​	添加padding、border元素会向内挤压



## 2.重排（回流）和重绘

**重排：**

​	重新生成布局，重新排列元素（重新计算各节点和css具体的大小和位置，渲染树需要计算所有受影响的节点），例：改变元素的宽高，触发重排。

**重绘：**

​	某些元素的外观被改变所触发浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程），例：修改元素背景颜色，触发重绘。



重排一定会重绘，重绘不一定重排。

通过两者概念区别明显得知，重排的成本比重绘大得多，应该减少重排的操作，减少页面性能消耗。



**以下会导致重排**

1. 页面初始渲染，这是开销最大的一次重排;

2. 添加/删除可见的DOM元素;

3. 改变元素位置;

4. 改变元素尺寸，比如边距、填充、边框、宽度和高度等;

5. 改变元素内容，比如文字数量，图片大小等;

6. 改变元素字体大小;

7. 改变浏览器窗口尺寸，比如resize事件发生时;

8. 激活CSS伪类（例如：:hover）;

9. 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow;

10. 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用getComputedStyl方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”;

![image-20230103214124466](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230103214124466.png)

**以下会发生重绘：**

- color
- border-style
- border-radius
- text-decoration
- box-shadow
- outline
- background
- ...



**优化建议：**

1. 合并对DOM样式的修改，采用css class来修改。

2. DOM离线处理，减少回流重绘次数（display：none）：

​	当对DOM 节点有较大改动的时候，我们先将元素脱离文档流，然后对元素进行操作，最后再把操作后的元素放回文档流。具体实现：修改DOM节点的display属性为none，临时将此节点从文档流中脱离，然后更改完css后再恢复display:block；

3. DOM脱离普通文档流：absolute 或 fixed。

4. CSS3硬件加速（常见css属性：transform、opacity、filters、Will-change）

5. 将节点设置为图层（图层能够解决该节点的渲染行为影响别的节点）

6. 对具有复杂动画的元素使用绝对定位，使之脱离文档流，否则会引起父元素及后续元素频繁回流。

7. 避免频繁操作DOM、样式

8. 避免使用css表达式（如：calc()）

9. 避免设置多层内联样式

10. 尽可能在DOM树的最末端改变class。



## 3.元素水平垂直居中

1. **flex布局(不定高，不定宽)**：display:flex；justify-content:center；align-items:center。
2. **absolute + transform**：父相子绝，子元素：top:50%; left:50%; transform:translate(-50%，-50%)；
3. **absolute + 负margin**：父相子绝，子元素：top:50%; left:50%; margin-left:-width*50%；margin-top:-height×50%；
4. **absolute + calc计算**：同上原理，利用calc计算好元素的 left 和 top 。
5. **display:table-cell**：父元素设置display:table-cell；vertical-align:middle；text-align:center；

6. **display:grid**：兼容性较差，未流行。display:grid；justify-content:center；align-items:center。



根据元素标签的性质，可以分为：

- 内联元素居中布局
- 块级元素居中布局

**内联元素居中布局**

水平居中

- 行内元素可设置：**text-align: center**
- **flex** 布局设置父元素：**display: flex** ; **justify-content: center**

垂直居中

- 单行文本父元素确认高度：**height === line-height**
- 多行文本父元素确认高度：**disaply: table-cell**; **vertical-align: middle**

**块级元素居中布局**

水平居中

- 定宽: **margin: 0 auto**
- 绝对定位 + **left:50%** + **margin:** 负自身一半

垂直居中

- **position: absolute** 设置 **left**、**top**、**margin-left**、**margin-top**(定高)
- **display: table-cell**
- **transform: translate(x, y)**
- **flex** (不定高，不定宽)
- **grid**(不定高，不定宽)，兼容性相对比较差







## 4.BFC

bfc：块级格式化上下文

理解：BFC是一块独立的区域，让处于BFC内部的元素与外部元素相互隔离。

实现BFC

1. 根元素（html标签），就是最大的BFC

2. 浮动元素float：float:none除外

3. 定位元素position（absolute(绝对定位)、fixed(固定定位)）

4. 弹性盒display：flex

5. Overflow除visible以外的值（hidden、auto、scroll）

6. 行内块（display:inline-block）

7. 表格单元(display:table,display:table-cell)



## 5.选择器优先级

第一优先级：`!important`会覆盖页面内任何位置的元素样式

1.内联样式，如`style="color: green"`，权值为`1000`

2.ID选择器，如`#app`，权值为`0100`

3.类、伪类、属性选择器，如`.foo, :first-child, div[class="foo"]`，权值为`0010`

4.标签、伪元素选择器，如`div::first-line`，权值为`0001`

5.通配符、子类选择器、兄弟选择器，如`*, >, +`，权值为`0000`

6.继承的样式没有权值



## 6.em和rem区别

rem是相对于根元素进行计算的，em是相对于当前元素或父元素的字体大小计算的。

rem不仅可以设置字体大小，还支持元素宽、高等属性。

em是相对于当前元素或父元素进行换算，层级越深，换算越复杂。rem是相当于根元素计算，避免层级关系。



## 5.移动端rem布局

获取屏幕宽度/UI设计图的宽度计算出html的fontSize大小，监听屏幕改变的事件，每次屏幕变化都重新计算。html中的所有像素为rem 根据html根元素的fontSize动态计算出px的值。

```js
<script type="text/javascript">
    function inMobile() {
        document.getElementsByTagName('html')[0].style.fontSize =
            (document.documentElement.clientWidth / 450) * 100 + 'px';
    }
    document.addEventListener('DOMContentLoaded', inMobile);
    window.onresize = inMobile;
</script>
```

第一步一般来说，我都会对移动端进行meta标签设置

viewport meta标签有六个属性

1. width：设置layout viewport 的宽度，为一个正整数，或字符串”width-device”
2. initial-scale：设置页面的初始缩放值，为数字，可带小数
3. minimum-scale： 允许用户的最小缩放值，为数字，可带小数
4. maximum-scale：允许用户的最大缩放值，为数字，可带小数
5. height 设置layout viewport 的高度
6. user-scalable 是否允许用户进行缩放，值为”no”或”yes”

<meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no" />







# 七、浏览器

## 1.常见的http请求

HTTP是超文本传输协议，用来定义客户端与服务端数据传输的规范

HTTP服务端默认端口80，HTTPS默认端口443

**HTTP请求方式**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72be9151a0764cd583595f355c9caa0c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)



## 2.POST和GET请求的区别

（1）本质区别

​		POST：向服务器传送数据

​		GET：向服务器获取数据

（2）请求参数形式

​		POST：附在正文中

​		GET：拼接在URL上

（3）请求数据大小限制

​		POST：正文没有限制

​		GET：URL长度有限制，在1024K左右

（4）安全性

​		GET：URL上可见传输参数，安全性低

（5）浏览器刷新是否重新请求

​		POST：是

​		GET：否



## 3.http状态码

**HTTP状态码共分为5种类型**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e654bf758a843fb910f28aa77b7269f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

**1XX（消息状态码）**

​	**100**：客户端应继续其请求。

​	**101**：切换协议。



**2XX（成功状态码）**：请求被正常处理了。

​	**200**：表示从客户端发来的请求在服务器被正常处理了。

​	**201**：一般用以POST请求，代表服务器资源创建成功。

​		场景：Github中，创建评论成功，则返回201。

​	**204**：表示请求处理成功，但没有资源可返回。

​		场景：PUT请求，修改资源的某个状态。

​					DELETE/OPTION请求，例取消关注某人成功则返回204。

​	**206**：当客户端指定 Range 范围请求头时，服务器端将会返回部分资源。

​		场景：当请求音视频资源体积过大时，一般使用206较多，哔哩哔哩使用较多。



**3XX（重定向）**：3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

​	**301**：永久重定向，该状态码表示请求的资源已被分配了新的 URL，以后应使用资源现在所指的 URL。该操作比较危险，需要谨慎操作：**如果设置了 301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向**。

​	**302**：临时重定向，已移动资源对应的 URL 将来还有可能发生改变。

​	**304**：资源已找到，但未符合条件请求。

​	该状态码表示客户端发送附带条件的请求时，**服务器端允许请求访问资源，但未满足条件的情况。**304 状态码返回时，不包含任何响应的主体部分。304 虽 然被划分在 3XX 类别中，但是**和重定向没有关系**。



 **4XX（客户端错误状态码）**：表明发生错误的原因是在客户端

​	**400**：该状态码表示**请求报文**中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

​	**401**：请求没有被认证或者认证失败, 这时客户端可以修改认证信息进行重试，着重于**认证**。

   		通常由web服务器返回，而不是web应用。
   	
   		场景：token失效，token缺失，token伪造，导致服务端无法识别身份。

​	**403**：表示授权失败，通常表示用户通过了身份验证，但缺少权限对给定的资源进行访问或者操作，着重于**授权**，通常由web应用返回。

​		   场景：用户登录成功，但是无权进行读写操作。

​	**404**：访问的资源不存在。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

​	**405**：客户端请求中的方法被禁止。



 **5XX（服务器错误状态码）**：服务器本身错误。

​	**500**：服务器执行请求时发生错误，无法完成请求。

​	**501**：服务器不支持请求的功能，无法完成请求。

​	**503**：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。延时的长度可包含在服务器的Retry-After头信息中。





## 4.浏览器存储方式

### **1.Cookie**

Cookie最开始并不是用于本地存储的，而是为了弥补HTTP在状态管理上的不足：

```
HTTP是一个无状态的协议，客户端向服务器发送请求，服务器返回响应，但是下一次发送请求时服务端就无法识别客户端的身份信息，故而产生了Cookie。
	Cookie它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。
```

使用起来也非常简单，`document.cookie = ....`即可。

封装一个简单的`setCookie`和`getCookie`方法

```js
function setCookie(c_name,value,expireseconds){
    var exdate=new Date();
    exdate.setTime(exdate.getTime()+expireseconds * 1000);
    document.cookie=c_name+ "=" +escape(value)+
    ((expireseconds==null) ? "" : ";expires="+exdate.toGMTString())
}
function getCookie(c_name){
    if (document.cookie.length>0){
        c_start=document.cookie.indexOf(c_name + "=");
        if (c_start!=-1){
            c_start=c_start + c_name.length+1;
            c_end=document.cookie.indexOf(";",c_start);
            if (c_end==-1){ 
                c_end=document.cookie.length;
            }
 
            return unescape(document.cookie.substring(c_start,c_end));
        }
     }
    return "";
}
setCookie('name','zzyn',60);  //cookie过期时间为60秒（1分钟）
getCookie('name')
```



**特点：**

1. 如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。

2. 只能保存字符串类型，以文本的方式。

   

**cookie缺点：**

	1. 容量缺陷：存储量太小，只有4KB。
	1. 性能缺陷：所有http请求都携带着，会影响获取资源的效率（Cookie是紧跟域名的，不管域名下面的某个地址需不需要这个Cookie，它都会携带上完整的Cookie。）
	1. 安全缺陷：由于Cookie以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，并在Cookie的有效期内重新发送给服务器。另外，在HTTPOnly为false的情况下，Cookie信息能直接通过JS脚本读取。

4. 用户可以操作（禁用）cookie，使功能受限；



**cookie应用场景：**

> 1. 判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须重新填写登录的相关信息。
> 2. 保存上次登录的时间等信息。
> 3. 保存上次查看的页面
> 4. 浏览计数



**cookie属性：**

| 属性     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| key      | cookie的键（名称）                                           |
| value    | cookie的值                                                   |
| max_age  | cookie被保存的时间数，单位为秒                               |
| expires  | 具体的过期时间，一个datetime对象或unix的时间戳               |
| path     | 限制cookie只在给定的路径可用，默认为整个域名下路径都可用     |
| domain   | 设置`cookie`可用的域名，默认是当前域名，子域名需要利用通配符`domain=.当前域名` |
| secure   | 设置为true，只有通过HTTPS才可以用                            |
| httponly | 设置为true，禁止客户端js获取cookie                           |

代码示例：

```js
document.cookie = "username=ziming; expires=Thu, 16 Dec 2015 12:00:00 GMT; path=/"    // 设置cookie
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT"    // 删除cookie
```



### 2.session

cookie和session都是用来跟踪浏览器用户的身份的方式。

session机制：

​	当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含session id。如果有session id，服务器将根据该id返回对应session对象。如果客户端请求中没有session id，服务器会创建新的session对象，并把session id在本次响应中返回给客户端。



**区别：**

1. 保存方式：

```
cookie保存在浏览器端；
session保存在服务器端；
```

2. 存储的大小：

​		cookie：单个cookie保存的数据不能超过4kb。

​		session大小理论上没有限制。

3. 安全性：

   cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；

   session的安全性大于cookie。



**session应用场景：**

session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。

> 1. 网上商城中的购物车
> 2. 保存用户登录信息
> 3. 将某些数据放入session中，供同一用户的不同页面使用
> 4. 防止用户非法登录



**缺点：**

```
1. Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。
2. 依赖于cookie（session id保存在cookie），如果禁用cookie，则要使用URL重写，不安全。
3. 创建session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。
```





### 3.Web storage API

Web Storage存储机制是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。

Web Storage提供两种类型的API：localStorage和sessionStorage

两者的区别看名字就有大概了解，localStorage在本地永久性存储数据，除非显式将其删除或清空；sessionStorage存储的数据只在会话期间有效，关闭浏览器则自动删除。



**1.localStorage：**

存储的是字符串，可以通过JSON的parse/stringify方法处理对象格式。

**优点：**

1. 存储量增大到 5MB。
2. 永久性存储。

3. 不会带到 HTTP 请求中，只存储在客户端，默认不参与与服务器端的通讯，这样就很好的避免了Cookie带来的性能和安全问题。

**应用场景：**

因为localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源；例如官网的logo，存储Base64格式的图片资源。



**2.sessionStorage：**

​	将数据保存在session对象中。

​	所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。

​	存储的是字符串，可以通过JSON的parse/stringify方法处理对象格式。

**特点：**

1. sessionStorage的容量上限也为5MB。
2. 只存储在客户端，默认不参与与服务器端的通讯。
3. sessionStorage的生命周期是在仅在当前会话下。

**应用场景：**

> 1. 可以使用sessionStorage对表单进行维护，将表单信息存储在里面，即使刷新表单也能保证不会让之前的表单信息丢失。
> 2. 可以使用sessionStorage来存储本次浏览记录，即那种关闭页面就不需要的浏览记录。



### 4.indexedDB

使用前端数据库。

当数据量不大时，我们可以通过`SessionStorage`或者`LocalStorage`来进行存储，但是当数据量较大，或符合一定的规范时，我们可以使用indexedDB数据库来进行数据的存储，indexedDB数据库存储理论上没有大小的限制。

**IndexedDB 鼓励使用的基本模式如下所示：**

> - 打开数据库。
> - 在数据库中创建一个对象仓库（object store）。
> - 启动一个事务，并发送一个请求来执行一些数据库操作，像增加或提取数据等。
> - 通过监听正确类型的 DOM 事件以等待操作完成。
> - 在操作结果上进行一些操作（可以在 request 对象中找到）
>    DEMO

缺点：indexedDB属于非关系型数据库，操作繁琐，对新手不友好。

代码示例：

```js
const req = window.indexDB.open('db_product', 1) // 打开/创建数据库
req.onsuccess = function (event) { // 监听数据库创建成功事件
    let db = event.target.result // 数据库对象
    console.log('数据库打开成功')
}
req.onerror = function (error) {
    console.log('数据库打开报错')
}
req.onupgradeneeded = function (event) {
    // 数据库创建或升级的时候会触发
    db = event.target.result
    let storeName = 'product' // 表名
    if (!db.objectStoreNames.contains(storeName)) { // 判断表是否存在
        let objectStore = db.createObjectStore(storeName, { keyPath: 'pro_id',autoIncrement: true })
    }
}
```



### 总结

| 特性         | cookie                                       | localStorage             | sessionStorage | indexDB                  |
| ------------ | -------------------------------------------- | ------------------------ | -------------- | ------------------------ |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间           | 除非被清理，否则一直存在 | 页面关闭被清理 | 除非被清理，否则一直存在 |
| 数据存储大小 | 4K                                           | 5M                       | 5M             | 无限                     |
| 与服务端通信 | 每次都会携带在 `header` 中，对于请求性能影响 | 不参与                   | 不参与         | 不参与                   |





## 5.浏览器http缓存

浏览器缓存：浏览器将用户请求过的静态资源，存储到本地内存，当浏览器再次访问时，就可以直接从本地加载，不用再次发起请求。

浏览器缓存的优点：

（1）减少服务器的负担，提高网站的性能

（2）加快客户端网页的加载速度

（3）减少多余网络数据传输

**浏览器缓存机制**

**强缓存**

​	我们第一次进入页面，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对资源进行缓存，如果响应头中expires、pragma或者cache-control字段，代表这是强缓存，浏览器就会把资源缓存在memory cache 或 disk cache中。

​	如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。

设置方式

Expires:服务器通过在响应头中添加expires属性，来指定资源的过期时间。在过期时间内，该资源可以被缓存使用，不必再像服务器发送请求，这是HTTP1.0的方式，有个缺点，就是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。因为用绝对时间可能存在误差导致缓存失败。

Cache-Control：因为expries的一些缺点，在HTTP1.1中提出这个属性，它提供了对资源的缓存的更精准的控制。Cache-Control使用了max-age相对时间，解决了expires的问题。通过设置max-age=xxx来进行强缓存。



**协商缓存**

强缓存失效后，浏览器向向服务器发送一个请求，如果资源没有发生修改，返回一个304状态，让浏览器使用本地的缓存副本。如果自愿发生修改，则返回修改后的资源。

设置方式

Etag&If-None-Match：服务器再返回资源时，在头信息中添加Etag属性，这个属性是资源生成的唯一标识符，当资源发生改变时，值也会发生变化。在下一次资源请求时，浏览器会在请求头中添加一个If-None-Match属性，这个属性的值就是上次返回的资源的Etag的值。服务器接受导请求后会根据这个值和资源当前的Etag的值进行比较，判断资源是否发生变化，是否返回资源。



## 6.web攻击方式

xss攻击

​	跨站脚本攻击，为了盗取存储在客户端的cookie或其他网站用于识别客户身份的敏感信息，一旦获取合法用户的信息后，攻击者可以假冒合法用户于网站进行交互

防御方法：过虑特殊字符

CSRF攻击

​	跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨域请求，利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某些操作



## 7.B端（对内）和C端（对外）区别

C端产品服务个人，B端产品服务组织

C端产品偏重用户体验，B端产品偏重信息流

C端产品转移成本远低于B端产品

C端产品依靠流量获取收益，B端产品通过付费定制获取利益



## 8.DOM和BOM区别

DOM（document object model）：文档对象模型，提供操作页面元素的方法和属性。

BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器。

Javascript 由三部分构成，ECMAScript，DOM和BOM。

1. ECMAScript(核心) ：描述了JS的语法和基本对象

2. DOM 是文档对象模型，处理网页内容的方法和接口。是W3C 的标准； [所有浏览器公共遵守的标准] 。

3. BOM 是浏览器对象模型，用于与浏览器窗口进行交互 核心对象为window，可用console.dir(window)查看window的属性和方法，**BOM包含了DOM**。各个浏览器厂商根据DOM在各自浏览器上的实现;[表现为不同浏览器定义有差别,实现方式不同] 。



**BOM 主要包括以下的对象模型：**

- window：包括全局属性、方法，控制浏览器窗口相关的属性、方法；

- location：浏览器连接到的对象的位置（URL）；

- history：操作浏览器的历史；

- document：当前窗口操作文档的对象；

  

**DOM和BOM的区别**

![image-20210801113943624的副本.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ce649d22dca42d59781b231cebd953a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

**window对象**

| **页面加载事件** |                                                           |
| ---------------- | --------------------------------------------------------- |
| load             | DOM全部加载完成                                           |
| DOMContentLoaded | 仅当DOM加载完成，不包括样式表，图片，flash等，ie9以上支持 |
| **调整窗口**     |                                                           |
| resize           | 窗口大小发生改变时（js实现响应式页面）                    |

| **定时器**                       |                                  |
| -------------------------------- | -------------------------------- |
| setTimeout() 和 clearTimeOut()   | 倒计时结束后，调用一次回调函数。 |
| setInterval() 和 clearInterval() | 每隔一段时间，调用一次回调函数。 |

**location对象**

location是最有用的BOM对象之一，提供了当前窗口中加载文档的信息，以及通常得导航功能

| **属性**           |                        |
| ------------------ | ---------------------- |
| location.href      | 返回完整的URL          |
| location.host      | 返回域名               |
| location.search    | 返回一个URL的查询部分  |
| **方法**           |                        |
| location.assign()  | 载入一个新的文档       |
| location.reload()  | 重新载入当前文档       |
| location.replace() | 用新的文档替换当前文档 |

**history对象**

History 对象包含用户（在浏览器窗口中）访问过的 URL。 History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问

| **属性**          |                                   |
| ----------------- | --------------------------------- |
| history.length    | 返回历史列表中的网址数            |
| **方法**          |                                   |
| history.forward() | 加载 history 列表中的前一个 URL   |
| history.back()    | 加载 history 列表中的下一个 URL   |
| history.go()      | 加载 history 列表中的某个具体页面 |



**常用DOM方法**

主要包括：增、删、改、查、事件操作

![image-20210730175217401.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fc9c1fb1a4b460796c054bb679e9493~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

**事件操作**

1. 事件三要素
   - 绑定元素
   - 触发事件
   - 响应函数

```
document.addEventListener(event, function[, useCapture])
```

| 参数               | 描述                                        |
| ------------------ | ------------------------------------------- |
| event（必选）      | 字符串，描述事件名称                        |
| function（必选）   | 函数，触发事件后执行的函数                  |
| useCapture（可选） | 布尔值，true捕获阶段执行，false冒泡阶段执行 |

1. 常用事件总结

| 常见事件（鼠标） | 触发条件                       |
| ---------------- | ------------------------------ |
| click            | 单击                           |
| dblclick         | 双击                           |
| mouseenter       | 鼠标悬停在元素上,替代mouseover |
| mouseleave       | 鼠标离开元素,替代mouseout      |
| focus            | 鼠标按键按下                   |
| blur             | 鼠标按键抬起                   |

| 常见事件（键盘） | 触发条件                                   |
| ---------------- | ------------------------------------------ |
| keydown          | 键盘按键按下                               |
| keypress         | 键盘按键按下，仅用于字符按键，不识别功能键 |
| keyup            | 键盘按键抬起                               |

> 执行顺序：keydown → keypress → keyup

1. DOM事件流

`DOM事件流`：DOM事件发生的顺序，可以分为事件捕获阶段和事件冒泡阶段。 ![image-20210731202702131的副本.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1d761b75d554a52938f92d554b07fe1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

> TIPS
>
> 1. onclick和attchEvent只有冒泡
> 2. document.addEventListener(event, function[, useCapture]) true为事件捕获，false/省略为事件冒泡
> 3. 部分事件类型无冒泡（blur...）

`事件委托（代理、委派）`：不给每个子元素单独设置事件监听，而是设置在其父元素上，利用冒泡原理间接设置到每个子节点，提升程序性能。

> 例子： 将多个子元素（li）的事件监听委托给父元素（ul），父元素利用event.target获取子元素，并通过子元素调用（call）

1. 事件对象

在触发 DOM 上事件时，会产生一个事件对象 event，这个对象中包含着所有与该事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。

ele.onclick = funciton(event) {}









# 八、TS

## 1.ts的了解

Ts可以理解为是js的拓展，不能直接引入到html中，不能直接被浏览器识别，需要通过babel转化后才能使用。

Ts是强类型语言，明确数据类型，代码可读性较强。

在项目中主要是做类型注解。





# 一. TypeScript简介

## 	官方文档

https://www.tslang.cn/docs/home.html

## 什么是TS

TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准（ES6 教程）。

TypeScript 由微软开发的自由和开源的编程语言。

TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。

## 	TS的优缺点

>TypeScript 增加了代码的可读性和可维护性
>1、类型系统实际上是最好的文档，大部分的函数看看类型的定义就知道如何使用了。
>2、可以在编译阶段就发现大部分的错误，这总比在运行时出错好。
>3、增强了编译器和IDE的功能，包括代码补全，接口提示，跳转到定义，重构等。
>
>TypeScript 非常包容
>1、Typescript是javascript的超集，.js文件可以直接重命名为。 ts即可。
>2、即使不显示的定义类型，也能够自动做出类型推导。
>3、可以定义从简单到复杂的几乎一切类型。
>4、兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以以编写单独的类型文件供 TypeScript 读取。
>
>Typescript的弊端在于:
>1、有一定的学习成本，需要理解接口，泛型，类，枚举类型等前端工程师可能不是很熟悉的概念。
>2、短期内会增加开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，Typescript能够减少其维护成本。
>3、集成到构建流程需要的一些工作量。
>4、可能和一些库结合的不是很完美。

## 	TS和JS的区别

>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。
>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。
>
>TypeScript是一个应用程序级的JavaScript开发语言。（这也表示TypeScript比较牛逼，可以开发大型应用，或者说更适合开发大型应用）
>TypeScript是JavaScript的超集，可以编译成纯JavaScript。这个和我们CSS里的Less或者Sass是很像的。
>我们用更好的代码编写方式来进行编写，最后还是有好生成原生的JavaScript语言。
>TypeScript跨浏览器、跨操作系统、跨主机、且开源。由于最后他编译成了JavaScript所以只要能运行JS的地方，都可以运行我们写的程序，设置在node.js里。
>TypeScript始于JavaScript，终于JavaScript。遵循JavaScript的语法和语义
>TypeScript可以重用JavaScript代码，调用流行的JavaScript库。
>TypeScript提供了类、模块和接口的概念，更易于构建组件和维护。
>TypeScript在原来JavaScript的基础之上添加了void/never/any/元组/枚举（enum）等高级类型。



# 二. 手册指南

## 1. 基础类型

### 1.1 数字

支持十进制和十六进制字面量，还支持ECMAScript 2015中的二进制和八进制字面量。

```ts
let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
```



### 1.2 布尔值

最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做`boolean`（其它语言中也一样）。

```ts
let isDone: boolean = false;
```



### 1.3 字符串

使用 `string`表示文本数据类型。

```ts
let name: string = "bob";
name = "smith";
```

你还可以使用*模版字符串*，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ ```），并且以`${ expr }`这种形式嵌入表达式

```ts
let name: string = `Gene`;
let age: number = 37;
let sentence: string = `
    Hello, my name is ${ name }.
    I'll be ${ age + 1 } years old next month.
`;
```

这与下面定义`sentence`的方式效果相同：

```ts
let sentence: string = "Hello, my name is " + name + ".\n\n" +
    "I'll be " + (age + 1) + " years old next month.";
```



### 1.4 数组

TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 `[]`，表示由此类型元素组成的一个数组：

```ts
let list: number[] = [1, 2, 3];
```

第二种方式是使用数组泛型，`Array<元素类型>`：

```ts
let list: Array<number> = [1, 2, 3];
```



### 1.5 元组 Tuple

元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。

元组就是固定长度的数组。

```ts
let x: [string, number];
x = ['hello', 10]; // OK
x = [10, 'hello']; // Error
```

当访问一个已知索引的元素，会得到正确的类型：

```ts
console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'
```



### 1.6 枚举

`enum`类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。

```ts
enum Color {Red, Green, Blue}
let c: Color = Color.Green;	//1
```

默认情况下，从`0`开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 `1`开始编号：

```ts
enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;	//2
```

或者，全部都采用手动赋值：

```ts
enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;	//2
```

枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：

```ts
enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

console.log(colorName);  // 显示'Green'因为上面代码里它的值是2
```



### 1.7 Any

any表示的是任意类型，一个变量设置any后相当于对该变量关闭了TS的类型检测。

```ts
let notSure: any = 4;
// let dnotSure //隐式any转换;

notSure = "maybe a string instead";
notSure = false;
```

当你只知道一部分数据的类型时，`any`类型也是有用的。

```ts
let list: any[] = [1, true, "free"];

list[1] = 100;
```





### 1.8 unknown

n2是未知类型，实际上就是一个类型安全的any，不能直接赋值给其他变量，需要做判断(2种)。

```ts
let n2: unknown;
n2 = 10;
n2 = 'hello';
n2 = false;

let s: string;
// 第一种，判断
if (typeof n2 === 'string') {
	s = n2;
}

// 第二种，类型断言，告诉解析器n2这个变量的实际类型(就是string类型)。
s = n2 as string;//类型断言
//s = <string>n2;类型断言
console.log(s);
```



### 1.9 Void

某种程度上来说，`void`类型像是与`any`类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 `void`：

以函数为例，就是代表没有返回值的函数

```ts
function warnUser(): void {
    //不能有返回值，但可以返回空 undefined;
    //return undefined;
    //return ;
}
```

声明一个`void`类型的变量没有什么用，因为你只能为它赋予`undefined`：

```ts
let unusable: void = undefined;
```



### 1.10 Never

`never`类型表示的是那些永不存在的值的类型。 例如， `never`类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never`类型，当它们被永不为真的类型保护所约束时。

`never`类型是任何类型的子类型，也可以赋值给任何类型；然而，*没有*类型是`never`的子类型或可以赋值给`never`类型（除了`never`本身之外）。 即使 `any`也不可以赋值给`never`。

下面是一些返回`never`类型的函数：

```ts
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
};

// 推断的返回值类型为never
function fail() {
    return error("Something failed");
};
```



### 1.11 Object

object 表示对象类型。

```ts
let obj:object;
obj = {};
obj = function (){};
```

{} 也表示对象类型，可指定包含有哪些属性。

```ts
// 语法: {属性名：属性值，属性名：属性值}，在属性名后加上？，表示属性可选的。
let obj2: {name:string,age?:number};
obj2 = {name:'孙悟空'};

// [propsName:string]:any 表示任意类型的属性，除了name是字符串，其他能为任意类型。
let obj3: {name:string,[propsName:string]:any};
obj3 = {name:'孙悟空2',age:25,sex:'男'};
```



### 1.12 类型断言

有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。



类型断言有两种形式。 其一是“尖括号”语法：

```ts
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;
```

另一个为`as`语法：

```ts
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
```

 

### 1.13 类型的别名

```ts
type myType = 1 | 2 | 3 | 4 | 5 ;
let n5: myType;	
let n6: myType;
let n7: myType;

n7 = 5;
```

 



## 2. 接口

接口的作用就是为类型命名和为你的代码或第三方代码定义契约。

为变量内部结构添加具体的数据类型。

```js
// 接口(大驼峰) 综合描述字段所包含的具体数据类型：即正常数据类型的内部数据类型的定义
// 主要作用是：定义数据类型的
interface Person { // 所有参数都为必传，可多传参数，不可少传参数。
    name: string,
    num: number,
    obj: object
}

function getObjVal(obj: Person, key: string) {
    return obj[key];
}

getObjVal({
  name: '张三12345',
  num: 12345,
  obj: {}
}, "name")
```



### 2.1 可选属性

接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。

```ts
interface SquareConfig {
  color?: string;
  width?: number;
}
```



### 2.2 只读属性

一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 `readonly`来指定只读属性:

```ts
interface Point {
    readonly x: number;
    readonly z: number;
}
```

你可以通过赋值一个对象字面量来构造一个`Point`。 赋值后， `x`和`y`再也不能被改变了。

```ts
let p1: Point = { x: 10, z: 20 };
p1.x = 5; // error!
```



#### 只读属性针对数组拓展 

TypeScript具有`ReadonlyArray<T>`类型，它与`Array<T>`相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：

```ts
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

上面代码的最后一行，可以看到就算把整个`ReadonlyArray`赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：

```ts
a = ro as number[];
```



`readonly` vs `const`

最简单判断该用`readonly`还是`const`的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 `const`，若做为属性则使用`readonly`。



### 2.3 函数类型

除了描述带有属性的普通对象外，接口也可以描述函数类型。

```ts
interface Fun {
	(a: string): number;//此处定义的number为返回值，并且和a的类型相同。
};
let fun: Fun = (a) => {
	return 12;
};
let a: number = fun('15');
```



### 2.4 可索引的类型

与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如`a[10]`或`ageMap["daniel"]`。 可索引类型具有一个 *索引签名*，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：

```ts
interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];

//或者---------------------------

interface StringArray {
  [index: string]: string;
}

let myArray: StringArray;
myArray = {title:"Bob", age:"Fred"};

let myStr: string = myArray["title"];
console.log(myStr);
```

上面例子里，我们定义了`StringArray`接口，它具有索引签名。 这个索引签名表示了当用 `number`去索引`StringArray`时会得到`string`类型的返回值。



### 2.5 实现类类型接口

与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。

```ts
interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
```

你也可以在接口中描述一个方法，在类里实现它，如同下面的`setTime`方法一样：

```ts
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
```





### 2.6 继承接口

和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。

```ts
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;
```

一个接口可以继承多个接口，创建出多个接口的合成接口。

```ts
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
```



###  2.7 接口的泛型

```ts
interface ine<T,Z>{
  title:T,
  age:Z
};

let obj:ine<string,number>={title:'张三',age:25};
```



### 2.8 把类当做接口使用

```js
class Point {
    x: number;
    y: number;
}

interface Point3d extends Point {
    z: number;
}

let point3d: Point3d = {x: 1, y: 2, z: 3};
```



## 3. 类

关系：

类与类：单继承

类与接口：多实现

接口与类：多继承

接口与接口：多继承

![image-20220627144332032](D:/1前端/10.专高五/专高五-高级Node（韩雨彤）/笔记/专高五-高级Node(7) (2)/专高五-高级Node.assets/image-20220627144332032.png)

类与接口的区别？

接口：规范成员方法和成员变量，声明成员方法和变量，没有具体实现。

类：实现成员变量或方法的具体实现的。



类实现接口的意义？

为了给类的成员方法和变量添加具体的规范（约束）





下面看一个使用类的例子：

```ts
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
```



### 3.1 继承

在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。

看下面的例子：

```ts
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
```

这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里， `Dog`是一个 *派生类*，它派生自 `Animal` *基类*，通过 `extends`关键字。 派生类通常被称作 *子类*，基类通常被称作 *超类*。

因为 `Dog`继承了 `Animal`的功能，因此我们可以创建一个 `Dog`的实例，它能够 `bark()`和 `move()`。



### 3.2 公共，私有与受保护的修饰符

#### public全局的(默认)

你也可以明确的将一个成员标记成 `public`。 我们可以用下面的方式来重写上面的 `Animal`类：

```ts
class Animal {
    public name: string;
    public constructor(theName: string) { this.name = theName; }
    public move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    };
};
```



#### private私有属性

当成员被标记成 `private`时，它就不能在声明它的类的外部访问。

```ts
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
};

new Animal("Cat").name; // 错误: 'name' 是私有的.
```

这个例子中有 `Animal`和 `Rhino`两个类， `Rhino`是 `Animal`类的子类。 还有一个 `Employee`类，其类型看上去与 `Animal`是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 `Animal`和 `Rhino`共享了来自 `Animal`里的私有成员定义 `private name: string`，因此它们是兼容的。 然而 `Employee`却不是这样。当把 `Employee`赋值给 `Animal`的时候，得到一个错误，说它们的类型不兼容。 尽管 `Employee`里也有一个私有成员 `name`，但它明显不是 `Animal`里面定义的那个。

```ts
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super("Rhino"); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal("Goat");
let rhino = new Rhino();
let employee = new Employee("Bob");

animal = rhino;
animal = employee; // 错误: Animal 与 Employee 不兼容.
```



#### protected

protected修饰符与 private修饰符的行为很相似，但有一点不同， `protected`成员在派生类中仍然可以访问，但不能在声明它的类的外部访问。

```ts
class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name)
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
console.log(howard.getElevatorPitch());
console.log(howard.name); // 错误
```

注意，我们不能在 `Person`类外使用 `name`，但是我们仍然可以通过 `Employee`类的实例方法访问，因为 `Employee`是由 `Person`派生而来的。

构造函数也可以被标记成 `protected`。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，

```ts
class Person {
    protected name: string;
    protected constructor(theName: string) { this.name = theName; }
}

// Employee 能够继承 Person
class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
let john = new Person("John"); // 错误: 'Person' 的构造函数是被保护的.
```



#### readonly只读修饰符

你可以使用 `readonly`关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。

```ts
class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs");
dad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.
```



### 3.3 存取器

```js
class AA {
    private _title: string

    get title(): string {
        return this._title;
    }

    set title(title: string) {
        this._title = title;
    }
}

let aa = new AA()
aa.title = '张三'
console.log(aa.title);

# 存取器上的属性必须和私有属性的名称保持一致
```



### 3.4 类的泛型

```js
class Person<T,Z> {
	// 修饰符，声明属性为私有属性，只能在类里访问，类外无法访问
	private username: T;
	nianling: Z;
	constructor(name: T, age: Z) {
		this.username = name;
		this.nianling = age;
	};
	sayHello(): Z {
		console.log(this.username);
		return this.nianling;
	};
};
let pers1 = new Person<string,number>('张三', 25);
let pers2 = new Person<string,number>('王五', 30);
console.log(pers1, pers2);
console.log(pers1.sayHello());
```







## 4. 函数

### 4.1 为函数定义类型

```ts
function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x + y; };
```



### 4.2 书写完整函数类型

```ts
let myAdd: (x: number, y: number) => number = function(x: number, y: number): number { return x + y; };
```



### 4.3 定义函数类型别名

```ts
type fnType = (a: number) => string;

let fn3:fnType = (a)=>{
  return 'hello';
}；

fn3(123);
```



### 4.4 可选参数和默认参数

可选参数

```ts
function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + " " + lastName;
    else
        return firstName;
};
```



为参数提供一个默认值当用户没有传递这个参数或传递的值是`undefined`时。 它们叫做有默认初始化值的参数。

```ts
function buildName(firstName: string, lastName = "Smith") {
    return firstName + " " + lastName;
}
```



### 4.5 剩余参数

必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 `arguments`来访问所有传入的参数。剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。

在TypeScript里，你可以把所有参数收集到一个变量里：

```ts
function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + " " + restOfName.join(" ");
  //restOfName=["Samuel", "Lucas", "MacKinzie"];
}

let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
```



### 4.6 通过接口声明一个函数类型

```ts
interface Fun {
	(a: string): number;
};
let fun: Fun = (a) => {
	return 12;
};
let a: number = fun('15');
```





## 5. 泛型

### 5.1 使用泛型变量

泛型,预先不确定类型，使用的时候才确定。

```ts
function loggingIdentity<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);
    return arg;
}
loggingIdentity<string>(['zhangsan']);
```



### 5.2 泛型函数

```ts
type fnType<T> = (a: T) => string;
let fn: fnType<number> = (a) => {
	return 'hello';
};
fn(123);

//-----------------------

type fnType<T> = (obj: T) => [T, boolean];
type obj = { title: string, age: number };
let fn: fnType1<obj1> = (obj) => {
	return [obj, false];
};
fn({ title: '张三', age: 25 });
```



### 5.3 接口的泛型

```ts
interface ine<T, Z> {
	title: T,
	age: Z
};
let obj: ine<string, number> = { title: '张三', age: 25 };
```



### 5.4 泛型类

泛型类看上去与泛型接口差不多。 泛型类使用（ `<>`）括起泛型类型，跟在类名后面。

```ts
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };

console.log(myGenericNumber.add(25, 25));
```



### 5.5 泛型约束

你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在 `loggingIdentity`例子中，我们想访问`arg`的`length`属性，但是编译器并不能证明每种类型都有`length`属性，所以就报错了。

```ts
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
```

为此，我们定义一个接口来描述约束条件。 创建一个包含 `.length`属性的接口，使用这个接口和`extends`关键字来实现约束：

```ts
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
```

现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：

```ts
loggingIdentity(3);  // Error, number doesn't have a .length property
```

我们需要传入符合约束类型的值，必须包含必须的属性：

```ts
loggingIdentity({length: 10, value: 3});
```





## 6. 高级类型

### 6.1 交叉类型

交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 

```ts
let data:{name:string} & {age:number};
data = {name:'孙悟空',age:500};
```

### 6.2 联合类型

联合类型表示一个值可以是几种类型之一。 我们用竖线（ `|`）分隔每个类型，所以 `number | string | boolean`表示一个值可以是 `number`， `string`，或 `boolean`。

```ts
function padLeft(value: string, padding: string | number) {
    // ...
};

let indentedString = padLeft("Hello world", true); // errors during 
```



### 6.3 类型别名

类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。

```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    }
    else {
        return n();
    }
}
```



### 6.4 字符串字面量类型

字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。

```ts
type Easing = "ease-in" | "ease-out" | "ease-in-out";
```



### 6.5 数字字面量类型

TypeScript还具有数字字面量类型。

```ts
function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 {
    // ...
}
```



### 6.6 索引类型(keyof)

#### 1. 基本用法

通过一个老的类型（对象类型）创建一个新的类型（联合类型）。

```js
type oldType = { title: string, age: number, id: number };
type newType = keyof oldType;	//'title' | 'age' | 'id'; 

let n: newType = 'title';
```

索引签名

```ts
interface int {
	[k: number]: number;	//索引签名
};
// 数组也能使用接口。
let data: int = [11, 22, 33];
```



#### 2. 索引类型的约束

```ts
//extends判断传的参数K必须是T的key值,并创建新的类型aType = { title: string; };
type aType<T, K extends keyof T> = {
	[key in K]: T[key];
};

let obj: aType<{ title: string; age: number }, "title"> = {
	title: '张三',
};
```





### 6.7 映射类型

#### 1. 基本用法

遍历联合类型里的每一项，组成一个新的对象类型。

```ts
type a = "title" | "age" | "id";
type type = { [k in a]: string | number };
//{ title: string | number; age: number | string; id: number | string; };

//------------------------------------------------------

type type = { title: string; age: number; id: number };

type newType = { [k in keyof type]: string };
//{ title: string; age: string; id: string; };

```



#### 2. 映射类型结合泛型

```ts
type type<T> = {
	[k in keyof T]: T[k];
};
type newType = type<{ title: string, age: number }>;

```



#### 3. 三元判断，更改属性值的类型 

```ts
type type<T> = {
    //当T[K]的类型是布尔值时候，改成number，否则用之前的类型。
	[k in keyof T]: T[k] extends boolean ? number : T[k];
};

type newType = type<{ title: string, age: number, id: boolean }>;

let data: newType = { title: 'zhangsan', age: 25, id: 15 };
```



#### 4. 映射类型和泛型的使用，更改只读属性和可选属性

```ts
type aType = {
	title: string;
	age?: number;
	readonly sex: number;
};

type bType<T> = {
	-readonly [k in keyof T]-?: T[k];
};

type newType = bType<aType>;

// newType = {
// 	title: string;
// 	age: number;
// 	sex: number;
// }
```





### 6.8 extends

#### 1. 继承

```ts
interface Atype {
   title: string;
}
interface Btype extends Atype {
   age: number;
}
```



#### 2. 类型约束

约束泛型

```ts
T extends {length:number}
```



约束联合类型 

```ts
//从T中寻找K，T的每一项会一一在K中查找是否有没有。
type aType<T, K> = T extends K ? never : T;
type newType = aType<"title" | "age" | "id" | "sex", "title" | "age">;
let a: newType = "id";

//------------------------------------------------------

type aType<T> = T extends null | undefined ? never : T;
type newType = aType<string | number | boolean | null | undefined>;
let a: newType = "1";//string|number|boolean;
```



## 7. 泛型内置工具类型

简化声明类型的操作。

```ts
interface type {
	title: string;
	age: number;
	class?: string;
};

//1.Partial把所有必选项换为可选项。
type newType = Partial<type>;

//2.Readonly只读属性。
type newType = Readonly<type>;

//3.Pick从原有属性组合一个新的属性类型。
type newType = Pick<type, 'age' | 'class'>;

//4.Omit从原有属性删除不需要的属性。
type newType = Omit<type1, 'age'>;

//5.Record根据联合类型得到一个对象类型。
type aType = "title" | "age" | "class";
type newType = Record<aType, string>;


//6.Required把所有可选项换为必选项。
type newType = Required<type>;

//---------------------------------------
type type2 = "title" | "age" | "id";
type type3 = "title";
//1.Exclude排除相同的，留下不同的。
type newType = Exclude<type2, type3>;

//2.Extract，留下相同的。
type newType = Extract<type2, type3>;

type type2 = number | string | boolean | null | undefined;
type newType = NonNullable<type2>;

//---------------------------------------

//1.ReturnType创建新的类型，是函数返回值的类型。
function fn() {
	return { title: '123' };
};
type type = ReturnType<typeof fn>;
//type={
//	title:string;
//};
```





## 8. 声明类型的文件（d.ts）

```ts
//创建type.d.ts文件

//抛出type
export declare type Item = {
	id: number;
	title: string;
	flag: boolean;
};
declare let a: number;

//抛出函数
declare function fun(): void;

//声明/抛出模块
declare module "path" {
	export function join(...a: string[]): string;
}

//命名空间
export namespace A {
	type aType = { title: string };
}

export namespace B {
	type aType = { age: number };
}
```

使用

```ts
import {fun,a,A,B,Item} from '../type.d';

let n: A.aType = {
	title: "张三"
};

let n1: B.aType = {
	age: 25,
};
```



## 9. 三斜线指令

///三斜线指令/相当于import ,用来引入第三方包的相关类型声明文件。

```ts
///<reference types="node"/>
///<reference types="react"/>
///<reference types="react-dom"/>
```









# 九、webpack





# 十、Git

## 1.git解决冲突

1. 先提交本地自己分支开发的代码 git add .  git commit -m ‘xxx’

2. 切换本地分支到master主分支	 git checkout master

3. 更新master分支代码  git pull

4. 切换到自己分支  git checkout 

5. 合并master最新代码  git rebase master

6. 查看冲突文件  git status

7. 解决冲突文件后，把冲突文件add

8. 所有冲突文件add完毕后，使用git rebase --continue继续合并

9. 使用 git status 查看状态，没问题后push到线上自己的分支



## 2.Git分支策略GitFlow

GitFlow 通常包含五种类型的分支：Master 分支、Develop 分支、Feature 分支、Release 分支以及 Hotfix 分支。

- **Master 分支**：主干分支，也是正式发布版本的分支，其包含可以部署到生产环境中的代码，通常情况下只允许其他分支将代码合入，不允许向 Master 分支直接提交代码（对应生产环境）。
- **Develop 分支**：开发分支，用来集成测试最新合入的开发成果，包含要发布到下一个 Release 的代码（对应开发环境）。
- **Feature 分支**：特性分支，通常从 Develop 分支拉出，每个新特性的开发对应一个特性分支，用于开发人员提交代码并进行自测。自测完成后，会将 Feature 分支的代码合并至 Develop 分支，进入下一个 Release。
- **Release 分支**：发布分支，发布新版本时，基于 Develop 分支创建，发布完成后，合并到 Master 和 Develop 分支（对应集成测试环境）。
- **Hot fix 分支**：热修复分支，生产环境发现新 Bug 时创建的临时分支，问题验证通过后，合并到 Master 和 Develop 分支。

通常开发过程中新特性的开发过程如下：

从 Develop 分支拉取一条 Feature 分支，开发团队在 Feature 分支上进行新功能开发；开发完成后，将 Feature 分支合入到 Develop 分支，并进行开发环境的验证；开发环境验证完成，从 Develop 分支拉取一条 Release 分支，到测试环境进行 SIT/UAT 测试；测试无问题后，可将 Develop 分支合入 Master 分支，待发版时，直接将 Master 分支代码部署到生产环境。

可参考下图：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf9d3f7fb60642b4862d47c0402fdf9d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

GitFlow 的优点是每个分支都有明确的定义，严格按照 GitFlow 管理项目代码的话，很难出现代码混乱；其缺点是：如果特性分支过多的话很容易造成代码冲突，从而提高了合入的成本；由于每次提交都涉及多个分支，所以 GitFlow 也太不适合提交频率较高的项目。







# 其他

## 1.MVVM、MVC和MVP概述

目的：分离视图和模型。

从MVC、MVP到MVVM，实际上是**模型和视图的分离过程**。**MVC中模型和视图没有完全分离**，造成代码臃肿，MVP中通过Presenter来进行中转，模型和视图彻底分离，但由于V和P互相引用，代码不够优雅。ViewModel通过数据绑定实现了视图和数据的绑定，解决了这种MVP的缺陷。



**1.MVC**

模型层(Model):负责存储、检索、操纵来自数据库或者网络的数据。

视图层(View):用户界面，一般采用XML文件进行界面的描述。

控制层(Controller):业务逻辑处理。

![image-20230206090944495](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230206090944495.png)

工作原理：

1. 当用户触发事件的时候，view层会发送指令到controller层，自己不执行业务逻辑。

2. controller执行业务逻辑并且操作Model，但不会直接操作View，可以说它是对View无知的。

3. model层更新完数据然后对视图进行更新，用户得到反馈。



Mvc优缺点：

优点：

1. 把业务逻辑全部分离到controller中，模块化程度高，重用度高，耦合性低。

2. 生命周期成本低，使开发和维护用户接口的技术含量降低。

3. 部署快。分离视图层和业务逻辑层，使得可维护性高。

缺点：

1. 所有通信都是单向的。

2. 增加系统结构和实现的复杂性，只适合大型项目的开发。

3. view层和model之间存在耦合。



**2.MVP**

MVP是从经典的MVC演变而来的，Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。

![image-20230206091008365](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230206091008365.png)

特点：

1. 各部分之间的通信，都是双向的。

2. view与model不发生联系，都通过Presenter传递。

3. view不部署任何业务逻辑，成为被动视图，既没有任何主动性。

工作原理：

1. View 接受用户请求。

2. View 传递请求给Presenter。

3. Presenter做逻辑处理，修改Model。

4. Model 通知Presenter数据变化。

5. Presenter 更新View。

MVP与MVC区别：

 	作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。



**3.MVVM**

本质上是MVC的改进版，和MVP基本一致。

**适合用于数据驱动场景，数据操作比较多的场景，耦合度低，可重用性，数据双向绑定。**

1. M：模型（Model）：对应data中的数据；

2. V：视图（View）：模板；

3. VM：视图模型（ViewModel）：Vue实例对象，连接视图和模型的桥梁，用来处理业务逻辑，实现数据的双向绑定；

![image-20230206091043632](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230206091043632.png)

工作原理：

1. View 接受用户请求。

2. View 传递请求给ViewModel。

3. ViewModel做逻辑处理，修改Model。

4. Model 更新完数据，通知ViewModel数据发生变化。

5. ViewModel更新View数据。



优点：

1. 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。

2. 可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。

MVVM与MVP的区别：

**基本上与MVP模式完全一致，唯一的区别是，它采用了双向绑定，View的 变动，自动反映在View Model，反之亦然。**



**为什么官方说Vue没有完全遵循MVVM思想？**

严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了 $refs 这个属性让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。





## 2.组件化思想和模块化思想

模块：向外提供特定功能的js程序，一般就是一个js文件。

组件：实现应用中局部功能的代码（html、css、js）和资源（音频视频）的集合。

![image-20230206091145717](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230206091145717.png)



![image-20230206091158425](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230206091158425.png)



![image-20230206091237829](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230206091237829.png)

![image-20230206091248607](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230206091248607.png)







## 3.在公司请求接口流程

拿到接口文档，发起请求：

一、在vue项目中，怎么设置代理来解决跨域的问题？

（从vue.config.js==》系统的配置文件）

1. 一切正常

2. 出现跨域：

​	(1) 前端解决（设置代理）：

​		① 需要在“开发环境”下将api请求代理到api服务器，注意生产模式不生效，需要设置环境变量，具体参考以下第三条。

​		② 具体配置：打开vue.config.js

```js
devServer:{
	proxy:’http://localhost:4000’
}
```

​			重启脚手架。

​	(2) 后端解决。

 

二、在公司里怎么做，前端请求接口封装的操作。

1. axios的二次封装，创建axios实例，设置请求拦截器和响应拦截器。

2. api的解耦，封装api便于使用与维护。

 

三、在公司里怎么做，项目上线如果出现请求的问题，怎么处理？

设置环境变量，参考vue官网

开发环境：项目根目录创建文件名为 .env.development 的文件。

生产环境：项目根目录创建文件名为 .env.production 的文件。

 

env文件设置以VUE_APP开始的名称。

例：

VUE_APP_TITLE = “这是开发环境”

VUE_APP_BASE_API = “https://xuexi.com” // (请求路径)

 

在项目中可以以process.env.VUE_APP_TITLE来访问环境变量中的值，开发环境下就是访问的.env.development文件中的VUE_APP_TITLE变量，因此可以根据设置环境变量来进行一些判断。

例：

![image-20230121125913565](C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230121125913565.png)





## 4.UI

1. 简述你使用的某个UI组件的的过程	

​	安装UI组件到项目中，使用List列表组件，把List引入到组件中，List中数据遍历的子组件为List.Item，每个List.Item中可以添加子元素为dom结构，List.Item中可以绑定点击事件，并且获取到遍历的每项的数据进行传递到详情页面。



2.  二次封装轮播图组件，包含不同样式的分页器，封装流程？

​	引入UI组件，组件中使用轮播图组件，定义配置项，使用props获取配置项的值，配置项{}中例如：data轮播图显示数据（必传），type分页器样式（选填，根据type的值判断使用哪种分页器样式）。



3. UI组件中栅格化是什么？

​	栅格系统以规则的网络阵列来指导和规范网页中的版面布局以及信息分布。栅格系统有时候也称为网格系统。
​	在网页设计中，如果把网页宽度平均切分为多个网格单元，每个单元之间预留一定的空隙。
​	网页栅格系统是从平面栅格系统中发展起来，对于网页设计来说，栅格系统的使用，不尽可以让网页的信息呈现更加美观易读、更具可用性，而且对于前端来说，网页将更加灵活与规范。



## 5.优化SPA应用的首屏加载速度慢的问题

1. 将公用的JS库通过script标签外部引入，减小 app.bundel 的大小，让浏览器并行下载资源文件，提高下载速度；
2. 在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；
3. 加一个首屏loading图，提升用户体验；
4. webpack相关配置优化。
5. 前端代码优化。

